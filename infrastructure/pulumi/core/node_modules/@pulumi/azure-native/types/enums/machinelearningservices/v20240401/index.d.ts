export declare const ApplicationSharingPolicy: {
    readonly Personal: "Personal";
    readonly Shared: "Shared";
};
/**
 * Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
 */
export type ApplicationSharingPolicy = (typeof ApplicationSharingPolicy)[keyof typeof ApplicationSharingPolicy];
export declare const AutoRebuildSetting: {
    readonly Disabled: "Disabled";
    readonly OnBaseImageUpdate: "OnBaseImageUpdate";
};
/**
 * Defines if image needs to be rebuilt based on base image changes.
 */
export type AutoRebuildSetting = (typeof AutoRebuildSetting)[keyof typeof AutoRebuildSetting];
export declare const BatchDeploymentConfigurationType: {
    readonly Model: "Model";
    readonly PipelineComponent: "PipelineComponent";
};
/**
 * [Required] The type of the deployment
 */
export type BatchDeploymentConfigurationType = (typeof BatchDeploymentConfigurationType)[keyof typeof BatchDeploymentConfigurationType];
export declare const BatchLoggingLevel: {
    readonly Info: "Info";
    readonly Warning: "Warning";
    readonly Debug: "Debug";
};
/**
 * Logging level for batch inference operation.
 */
export type BatchLoggingLevel = (typeof BatchLoggingLevel)[keyof typeof BatchLoggingLevel];
export declare const BatchOutputAction: {
    readonly SummaryOnly: "SummaryOnly";
    readonly AppendRow: "AppendRow";
};
/**
 * Indicates how the output will be organized.
 */
export type BatchOutputAction = (typeof BatchOutputAction)[keyof typeof BatchOutputAction];
export declare const BlockedTransformers: {
    /**
     * Target encoding for text data.
     */
    readonly TextTargetEncoder: "TextTargetEncoder";
    /**
     * Ohe hot encoding creates a binary feature transformation.
     */
    readonly OneHotEncoder: "OneHotEncoder";
    /**
     * Target encoding for categorical data.
     */
    readonly CatTargetEncoder: "CatTargetEncoder";
    /**
     * Tf-Idf stands for, term-frequency times inverse document-frequency. This is a common term weighting scheme for identifying information from documents.
     */
    readonly TfIdf: "TfIdf";
    /**
     * Weight of Evidence encoding is a technique used to encode categorical variables. It uses the natural log of the P(1)/P(0) to create weights.
     */
    readonly WoETargetEncoder: "WoETargetEncoder";
    /**
     * Label encoder converts labels/categorical variables in a numerical form.
     */
    readonly LabelEncoder: "LabelEncoder";
    /**
     * Word embedding helps represents words or phrases as a vector, or a series of numbers.
     */
    readonly WordEmbedding: "WordEmbedding";
    /**
     * Naive Bayes is a classified that is used for classification of discrete features that are categorically distributed.
     */
    readonly NaiveBayes: "NaiveBayes";
    /**
     * Count Vectorizer converts a collection of text documents to a matrix of token counts.
     */
    readonly CountVectorizer: "CountVectorizer";
    /**
     * Hashing One Hot Encoder can turn categorical variables into a limited number of new features. This is often used for high-cardinality categorical features.
     */
    readonly HashOneHotEncoder: "HashOneHotEncoder";
};
/**
 * Enum for all classification models supported by AutoML.
 */
export type BlockedTransformers = (typeof BlockedTransformers)[keyof typeof BlockedTransformers];
export declare const CategoricalDataDriftMetric: {
    /**
     * The Jensen Shannon Distance (JSD) metric.
     */
    readonly JensenShannonDistance: "JensenShannonDistance";
    /**
     * The Population Stability Index (PSI) metric.
     */
    readonly PopulationStabilityIndex: "PopulationStabilityIndex";
    /**
     * The Pearsons Chi Squared Test metric.
     */
    readonly PearsonsChiSquaredTest: "PearsonsChiSquaredTest";
};
/**
 * [Required] The categorical data drift metric to calculate.
 */
export type CategoricalDataDriftMetric = (typeof CategoricalDataDriftMetric)[keyof typeof CategoricalDataDriftMetric];
export declare const CategoricalDataQualityMetric: {
    /**
     * Calculates the rate of null values.
     */
    readonly NullValueRate: "NullValueRate";
    /**
     * Calculates the rate of data type errors.
     */
    readonly DataTypeErrorRate: "DataTypeErrorRate";
    /**
     * Calculates the rate values are out of bounds.
     */
    readonly OutOfBoundsRate: "OutOfBoundsRate";
};
/**
 * [Required] The categorical data quality metric to calculate.
 */
export type CategoricalDataQualityMetric = (typeof CategoricalDataQualityMetric)[keyof typeof CategoricalDataQualityMetric];
export declare const CategoricalPredictionDriftMetric: {
    /**
     * The Jensen Shannon Distance (JSD) metric.
     */
    readonly JensenShannonDistance: "JensenShannonDistance";
    /**
     * The Population Stability Index (PSI) metric.
     */
    readonly PopulationStabilityIndex: "PopulationStabilityIndex";
    /**
     * The Pearsons Chi Squared Test metric.
     */
    readonly PearsonsChiSquaredTest: "PearsonsChiSquaredTest";
};
/**
 * [Required] The categorical prediction drift metric to calculate.
 */
export type CategoricalPredictionDriftMetric = (typeof CategoricalPredictionDriftMetric)[keyof typeof CategoricalPredictionDriftMetric];
export declare const ClassificationModels: {
    /**
     * Logistic regression is a fundamental classification technique.
     * It belongs to the group of linear classifiers and is somewhat similar to polynomial and linear regression.
     * Logistic regression is fast and relatively uncomplicated, and it's convenient for you to interpret the results.
     * Although it's essentially a method for binary classification, it can also be applied to multiclass problems.
     */
    readonly LogisticRegression: "LogisticRegression";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     */
    readonly SGD: "SGD";
    /**
     * The multinomial Naive Bayes classifier is suitable for classification with discrete features (e.g., word counts for text classification).
     * The multinomial distribution normally requires integer feature counts. However, in practice, fractional counts such as tf-idf may also work.
     */
    readonly MultinomialNaiveBayes: "MultinomialNaiveBayes";
    /**
     * Naive Bayes classifier for multivariate Bernoulli models.
     */
    readonly BernoulliNaiveBayes: "BernoulliNaiveBayes";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     */
    readonly SVM: "SVM";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     * Linear SVM performs best when input data is linear, i.e., data can be easily classified by drawing the straight line between classified values on a plotted graph.
     */
    readonly LinearSVM: "LinearSVM";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    readonly KNN: "KNN";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    readonly DecisionTree: "DecisionTree";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    readonly RandomForest: "RandomForest";
    /**
     * Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
     */
    readonly ExtremeRandomTrees: "ExtremeRandomTrees";
    /**
     * LightGBM is a gradient boosting framework that uses tree based learning algorithms.
     */
    readonly LightGBM: "LightGBM";
    /**
     * The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
     */
    readonly GradientBoosting: "GradientBoosting";
    /**
     * XGBoost: Extreme Gradient Boosting Algorithm. This algorithm is used for structured data where target column values can be divided into distinct class values.
     */
    readonly XGBoostClassifier: "XGBoostClassifier";
};
/**
 * Enum for all classification models supported by AutoML.
 */
export type ClassificationModels = (typeof ClassificationModels)[keyof typeof ClassificationModels];
export declare const ClassificationMultilabelPrimaryMetrics: {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    readonly AUCWeighted: "AUCWeighted";
    /**
     * Accuracy is the ratio of predictions that exactly match the true class labels.
     */
    readonly Accuracy: "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    readonly NormMacroRecall: "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    readonly AveragePrecisionScoreWeighted: "AveragePrecisionScoreWeighted";
    /**
     * The arithmetic mean of precision for each class, weighted by number of true instances in each class.
     */
    readonly PrecisionScoreWeighted: "PrecisionScoreWeighted";
    /**
     * Intersection Over Union. Intersection of predictions divided by union of predictions.
     */
    readonly IOU: "IOU";
};
/**
 * Primary metric to optimize for this task.
 */
export type ClassificationMultilabelPrimaryMetrics = (typeof ClassificationMultilabelPrimaryMetrics)[keyof typeof ClassificationMultilabelPrimaryMetrics];
export declare const ClassificationPrimaryMetrics: {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    readonly AUCWeighted: "AUCWeighted";
    /**
     * Accuracy is the ratio of predictions that exactly match the true class labels.
     */
    readonly Accuracy: "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    readonly NormMacroRecall: "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    readonly AveragePrecisionScoreWeighted: "AveragePrecisionScoreWeighted";
    /**
     * The arithmetic mean of precision for each class, weighted by number of true instances in each class.
     */
    readonly PrecisionScoreWeighted: "PrecisionScoreWeighted";
};
/**
 * Primary metric for Text-Classification task.
 */
export type ClassificationPrimaryMetrics = (typeof ClassificationPrimaryMetrics)[keyof typeof ClassificationPrimaryMetrics];
export declare const ClusterPurpose: {
    readonly FastProd: "FastProd";
    readonly DenseProd: "DenseProd";
    readonly DevTest: "DevTest";
};
/**
 * Intended usage of the cluster
 */
export type ClusterPurpose = (typeof ClusterPurpose)[keyof typeof ClusterPurpose];
export declare const ComputeInstanceAuthorizationType: {
    readonly Personal: "personal";
};
/**
 * The Compute Instance Authorization type. Available values are personal (default).
 */
export type ComputeInstanceAuthorizationType = (typeof ComputeInstanceAuthorizationType)[keyof typeof ComputeInstanceAuthorizationType];
export declare const ComputePowerAction: {
    readonly Start: "Start";
    readonly Stop: "Stop";
};
/**
 * [Required] The compute power action.
 */
export type ComputePowerAction = (typeof ComputePowerAction)[keyof typeof ComputePowerAction];
export declare const ComputeRecurrenceFrequency: {
    /**
     * Minute frequency
     */
    readonly Minute: "Minute";
    /**
     * Hour frequency
     */
    readonly Hour: "Hour";
    /**
     * Day frequency
     */
    readonly Day: "Day";
    /**
     * Week frequency
     */
    readonly Week: "Week";
    /**
     * Month frequency
     */
    readonly Month: "Month";
};
/**
 * [Required] The frequency to trigger schedule.
 */
export type ComputeRecurrenceFrequency = (typeof ComputeRecurrenceFrequency)[keyof typeof ComputeRecurrenceFrequency];
export declare const ComputeTriggerType: {
    readonly Recurrence: "Recurrence";
    readonly Cron: "Cron";
};
/**
 * [Required] The schedule trigger type.
 */
export type ComputeTriggerType = (typeof ComputeTriggerType)[keyof typeof ComputeTriggerType];
export declare const ComputeType: {
    readonly AKS: "AKS";
    readonly Kubernetes: "Kubernetes";
    readonly AmlCompute: "AmlCompute";
    readonly ComputeInstance: "ComputeInstance";
    readonly DataFactory: "DataFactory";
    readonly VirtualMachine: "VirtualMachine";
    readonly HDInsight: "HDInsight";
    readonly Databricks: "Databricks";
    readonly DataLakeAnalytics: "DataLakeAnalytics";
    readonly SynapseSpark: "SynapseSpark";
};
/**
 * The type of compute
 */
export type ComputeType = (typeof ComputeType)[keyof typeof ComputeType];
export declare const ComputeWeekDay: {
    /**
     * Monday weekday
     */
    readonly Monday: "Monday";
    /**
     * Tuesday weekday
     */
    readonly Tuesday: "Tuesday";
    /**
     * Wednesday weekday
     */
    readonly Wednesday: "Wednesday";
    /**
     * Thursday weekday
     */
    readonly Thursday: "Thursday";
    /**
     * Friday weekday
     */
    readonly Friday: "Friday";
    /**
     * Saturday weekday
     */
    readonly Saturday: "Saturday";
    /**
     * Sunday weekday
     */
    readonly Sunday: "Sunday";
};
/**
 * Enum of weekday
 */
export type ComputeWeekDay = (typeof ComputeWeekDay)[keyof typeof ComputeWeekDay];
export declare const ConnectionAuthType: {
    readonly PAT: "PAT";
    readonly ManagedIdentity: "ManagedIdentity";
    readonly UsernamePassword: "UsernamePassword";
    readonly None: "None";
    readonly SAS: "SAS";
    readonly AccountKey: "AccountKey";
    readonly ServicePrincipal: "ServicePrincipal";
    readonly AccessKey: "AccessKey";
    readonly ApiKey: "ApiKey";
    readonly CustomKeys: "CustomKeys";
    readonly OAuth2: "OAuth2";
    readonly AAD: "AAD";
};
/**
 * Authentication type of the connection target
 */
export type ConnectionAuthType = (typeof ConnectionAuthType)[keyof typeof ConnectionAuthType];
export declare const ConnectionCategory: {
    readonly PythonFeed: "PythonFeed";
    readonly ContainerRegistry: "ContainerRegistry";
    readonly Git: "Git";
    readonly S3: "S3";
    readonly Snowflake: "Snowflake";
    readonly AzureSqlDb: "AzureSqlDb";
    readonly AzureSynapseAnalytics: "AzureSynapseAnalytics";
    readonly AzureMySqlDb: "AzureMySqlDb";
    readonly AzurePostgresDb: "AzurePostgresDb";
    readonly ADLSGen2: "ADLSGen2";
    readonly Redis: "Redis";
    readonly ApiKey: "ApiKey";
    readonly AzureOpenAI: "AzureOpenAI";
    readonly CognitiveSearch: "CognitiveSearch";
    readonly CognitiveService: "CognitiveService";
    readonly CustomKeys: "CustomKeys";
    readonly AzureBlob: "AzureBlob";
    readonly AzureOneLake: "AzureOneLake";
    readonly CosmosDb: "CosmosDb";
    readonly CosmosDbMongoDbApi: "CosmosDbMongoDbApi";
    readonly AzureDataExplorer: "AzureDataExplorer";
    readonly AzureMariaDb: "AzureMariaDb";
    readonly AzureDatabricksDeltaLake: "AzureDatabricksDeltaLake";
    readonly AzureSqlMi: "AzureSqlMi";
    readonly AzureTableStorage: "AzureTableStorage";
    readonly AmazonRdsForOracle: "AmazonRdsForOracle";
    readonly AmazonRdsForSqlServer: "AmazonRdsForSqlServer";
    readonly AmazonRedshift: "AmazonRedshift";
    readonly Db2: "Db2";
    readonly Drill: "Drill";
    readonly GoogleBigQuery: "GoogleBigQuery";
    readonly Greenplum: "Greenplum";
    readonly Hbase: "Hbase";
    readonly Hive: "Hive";
    readonly Impala: "Impala";
    readonly Informix: "Informix";
    readonly MariaDb: "MariaDb";
    readonly MicrosoftAccess: "MicrosoftAccess";
    readonly MySql: "MySql";
    readonly Netezza: "Netezza";
    readonly Oracle: "Oracle";
    readonly Phoenix: "Phoenix";
    readonly PostgreSql: "PostgreSql";
    readonly Presto: "Presto";
    readonly SapOpenHub: "SapOpenHub";
    readonly SapBw: "SapBw";
    readonly SapHana: "SapHana";
    readonly SapTable: "SapTable";
    readonly Spark: "Spark";
    readonly SqlServer: "SqlServer";
    readonly Sybase: "Sybase";
    readonly Teradata: "Teradata";
    readonly Vertica: "Vertica";
    readonly Cassandra: "Cassandra";
    readonly Couchbase: "Couchbase";
    readonly MongoDbV2: "MongoDbV2";
    readonly MongoDbAtlas: "MongoDbAtlas";
    readonly AmazonS3Compatible: "AmazonS3Compatible";
    readonly FileServer: "FileServer";
    readonly FtpServer: "FtpServer";
    readonly GoogleCloudStorage: "GoogleCloudStorage";
    readonly Hdfs: "Hdfs";
    readonly OracleCloudStorage: "OracleCloudStorage";
    readonly Sftp: "Sftp";
    readonly GenericHttp: "GenericHttp";
    readonly ODataRest: "ODataRest";
    readonly Odbc: "Odbc";
    readonly GenericRest: "GenericRest";
    readonly AmazonMws: "AmazonMws";
    readonly Concur: "Concur";
    readonly Dynamics: "Dynamics";
    readonly DynamicsAx: "DynamicsAx";
    readonly DynamicsCrm: "DynamicsCrm";
    readonly GoogleAdWords: "GoogleAdWords";
    readonly Hubspot: "Hubspot";
    readonly Jira: "Jira";
    readonly Magento: "Magento";
    readonly Marketo: "Marketo";
    readonly Office365: "Office365";
    readonly Eloqua: "Eloqua";
    readonly Responsys: "Responsys";
    readonly OracleServiceCloud: "OracleServiceCloud";
    readonly PayPal: "PayPal";
    readonly QuickBooks: "QuickBooks";
    readonly Salesforce: "Salesforce";
    readonly SalesforceServiceCloud: "SalesforceServiceCloud";
    readonly SalesforceMarketingCloud: "SalesforceMarketingCloud";
    readonly SapCloudForCustomer: "SapCloudForCustomer";
    readonly SapEcc: "SapEcc";
    readonly ServiceNow: "ServiceNow";
    readonly SharePointOnlineList: "SharePointOnlineList";
    readonly Shopify: "Shopify";
    readonly Square: "Square";
    readonly WebTable: "WebTable";
    readonly Xero: "Xero";
    readonly Zoho: "Zoho";
    readonly GenericContainerRegistry: "GenericContainerRegistry";
    readonly OpenAI: "OpenAI";
    readonly Serp: "Serp";
    readonly BingLLMSearch: "BingLLMSearch";
    readonly Serverless: "Serverless";
    readonly AIServices: "AIServices";
};
/**
 * Category of the connection
 */
export type ConnectionCategory = (typeof ConnectionCategory)[keyof typeof ConnectionCategory];
export declare const ContainerType: {
    readonly StorageInitializer: "StorageInitializer";
    readonly InferenceServer: "InferenceServer";
};
/**
 * The type of container to retrieve logs from.
 */
export type ContainerType = (typeof ContainerType)[keyof typeof ContainerType];
export declare const ContentSafetyStatus: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * [Required] Specifies the status of content safety.
 */
export type ContentSafetyStatus = (typeof ContentSafetyStatus)[keyof typeof ContentSafetyStatus];
export declare const CredentialsType: {
    readonly AccountKey: "AccountKey";
    readonly Certificate: "Certificate";
    readonly None: "None";
    readonly Sas: "Sas";
    readonly ServicePrincipal: "ServicePrincipal";
};
/**
 * [Required] Credential type used to authentication with storage.
 */
export type CredentialsType = (typeof CredentialsType)[keyof typeof CredentialsType];
export declare const DataCollectionMode: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Enable or disable data collection.
 */
export type DataCollectionMode = (typeof DataCollectionMode)[keyof typeof DataCollectionMode];
export declare const DataType: {
    readonly Uri_file: "uri_file";
    readonly Uri_folder: "uri_folder";
    readonly Mltable: "mltable";
};
/**
 * [Required] Specifies the type of data.
 */
export type DataType = (typeof DataType)[keyof typeof DataType];
export declare const DatastoreType: {
    readonly AzureBlob: "AzureBlob";
    readonly AzureDataLakeGen1: "AzureDataLakeGen1";
    readonly AzureDataLakeGen2: "AzureDataLakeGen2";
    readonly AzureFile: "AzureFile";
    readonly OneLake: "OneLake";
};
/**
 * [Required] Storage type backing the datastore.
 */
export type DatastoreType = (typeof DatastoreType)[keyof typeof DatastoreType];
export declare const DistributionType: {
    readonly PyTorch: "PyTorch";
    readonly TensorFlow: "TensorFlow";
    readonly Mpi: "Mpi";
};
/**
 * [Required] Specifies the type of distribution framework.
 */
export type DistributionType = (typeof DistributionType)[keyof typeof DistributionType];
export declare const EarlyTerminationPolicyType: {
    readonly Bandit: "Bandit";
    readonly MedianStopping: "MedianStopping";
    readonly TruncationSelection: "TruncationSelection";
};
/**
 * [Required] Name of policy configuration
 */
export type EarlyTerminationPolicyType = (typeof EarlyTerminationPolicyType)[keyof typeof EarlyTerminationPolicyType];
export declare const EgressPublicNetworkAccessType: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
 */
export type EgressPublicNetworkAccessType = (typeof EgressPublicNetworkAccessType)[keyof typeof EgressPublicNetworkAccessType];
export declare const EmailNotificationEnableType: {
    readonly JobCompleted: "JobCompleted";
    readonly JobFailed: "JobFailed";
    readonly JobCancelled: "JobCancelled";
};
/**
 * Enum to determine the email notification type.
 */
export type EmailNotificationEnableType = (typeof EmailNotificationEnableType)[keyof typeof EmailNotificationEnableType];
export declare const EncryptionStatus: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Indicates whether or not the encryption is enabled for the workspace.
 */
export type EncryptionStatus = (typeof EncryptionStatus)[keyof typeof EncryptionStatus];
export declare const EndpointAuthMode: {
    readonly AMLToken: "AMLToken";
    readonly Key: "Key";
    readonly AADToken: "AADToken";
};
/**
 * [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
 */
export type EndpointAuthMode = (typeof EndpointAuthMode)[keyof typeof EndpointAuthMode];
export declare const EndpointComputeType: {
    readonly Managed: "Managed";
    readonly Kubernetes: "Kubernetes";
    readonly AzureMLCompute: "AzureMLCompute";
};
/**
 * [Required] The compute type of the endpoint.
 */
export type EndpointComputeType = (typeof EndpointComputeType)[keyof typeof EndpointComputeType];
export declare const EndpointServiceConnectionStatus: {
    readonly Approved: "Approved";
    readonly Pending: "Pending";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
};
/**
 * Connection status of the service consumer with the service provider
 */
export type EndpointServiceConnectionStatus = (typeof EndpointServiceConnectionStatus)[keyof typeof EndpointServiceConnectionStatus];
export declare const EnvironmentVariableType: {
    readonly Local: "local";
};
/**
 * Type of the Environment Variable. Possible values are: local - For local variable
 */
export type EnvironmentVariableType = (typeof EnvironmentVariableType)[keyof typeof EnvironmentVariableType];
export declare const FeatureAttributionMetric: {
    /**
     * The Normalized Discounted Cumulative Gain metric.
     */
    readonly NormalizedDiscountedCumulativeGain: "NormalizedDiscountedCumulativeGain";
};
/**
 * [Required] The feature attribution metric to calculate.
 */
export type FeatureAttributionMetric = (typeof FeatureAttributionMetric)[keyof typeof FeatureAttributionMetric];
export declare const FeatureDataType: {
    readonly String: "String";
    readonly Integer: "Integer";
    readonly Long: "Long";
    readonly Float: "Float";
    readonly Double: "Double";
    readonly Binary: "Binary";
    readonly Datetime: "Datetime";
    readonly Boolean: "Boolean";
};
/**
 * Specifies the data type
 */
export type FeatureDataType = (typeof FeatureDataType)[keyof typeof FeatureDataType];
export declare const FeatureImportanceMode: {
    /**
     * Disables computing feature importance within a signal.
     */
    readonly Disabled: "Disabled";
    /**
     * Enables computing feature importance within a signal.
     */
    readonly Enabled: "Enabled";
};
/**
 * The mode of operation for computing feature importance.
 */
export type FeatureImportanceMode = (typeof FeatureImportanceMode)[keyof typeof FeatureImportanceMode];
export declare const FeatureLags: {
    /**
     * No feature lags generated.
     */
    readonly None: "None";
    /**
     * System auto-generates feature lags.
     */
    readonly Auto: "Auto";
};
/**
 * Flag for generating lags for the numeric features with 'auto' or null.
 */
export type FeatureLags = (typeof FeatureLags)[keyof typeof FeatureLags];
export declare const FeaturizationMode: {
    /**
     * Auto mode, system performs featurization without any custom featurization inputs.
     */
    readonly Auto: "Auto";
    /**
     * Custom featurization.
     */
    readonly Custom: "Custom";
    /**
     * Featurization off. 'Forecasting' task cannot use this value.
     */
    readonly Off: "Off";
};
/**
 * Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
 * If 'Off' is selected then no featurization is done.
 * If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
 */
export type FeaturizationMode = (typeof FeaturizationMode)[keyof typeof FeaturizationMode];
export declare const ForecastHorizonMode: {
    /**
     * Forecast horizon to be determined automatically.
     */
    readonly Auto: "Auto";
    /**
     * Use the custom forecast horizon.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] Set forecast horizon value selection mode.
 */
export type ForecastHorizonMode = (typeof ForecastHorizonMode)[keyof typeof ForecastHorizonMode];
export declare const ForecastingModels: {
    /**
     * Auto-Autoregressive Integrated Moving Average (ARIMA) model uses time-series data and statistical analysis to interpret the data and make future predictions.
     * This model aims to explain data by using time series data on its past values and uses linear regression to make predictions.
     */
    readonly AutoArima: "AutoArima";
    /**
     * Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects.
     * It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.
     */
    readonly Prophet: "Prophet";
    /**
     * The Naive forecasting model makes predictions by carrying forward the latest target value for each time-series in the training data.
     */
    readonly Naive: "Naive";
    /**
     * The Seasonal Naive forecasting model makes predictions by carrying forward the latest season of target values for each time-series in the training data.
     */
    readonly SeasonalNaive: "SeasonalNaive";
    /**
     * The Average forecasting model makes predictions by carrying forward the average of the target values for each time-series in the training data.
     */
    readonly Average: "Average";
    /**
     * The Seasonal Average forecasting model makes predictions by carrying forward the average value of the latest season of data for each time-series in the training data.
     */
    readonly SeasonalAverage: "SeasonalAverage";
    /**
     * Exponential smoothing is a time series forecasting method for univariate data that can be extended to support data with a systematic trend or seasonal component.
     */
    readonly ExponentialSmoothing: "ExponentialSmoothing";
    /**
     * An Autoregressive Integrated Moving Average with Explanatory Variable (ARIMAX) model can be viewed as a multiple regression model with one or more autoregressive (AR) terms and/or one or more moving average (MA) terms.
     * This method is suitable for forecasting when data is stationary/non stationary, and multivariate with any type of data pattern, i.e., level/trend /seasonality/cyclicity.
     */
    readonly Arimax: "Arimax";
    /**
     * TCNForecaster: Temporal Convolutional Networks Forecaster. //TODO: Ask forecasting team for brief intro.
     */
    readonly TCNForecaster: "TCNForecaster";
    /**
     * Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions.
     */
    readonly ElasticNet: "ElasticNet";
    /**
     * The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
     */
    readonly GradientBoosting: "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    readonly DecisionTree: "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    readonly KNN: "KNN";
    /**
     * Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer.
     */
    readonly LassoLars: "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    readonly SGD: "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    readonly RandomForest: "RandomForest";
    /**
     * Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
     */
    readonly ExtremeRandomTrees: "ExtremeRandomTrees";
    /**
     * LightGBM is a gradient boosting framework that uses tree based learning algorithms.
     */
    readonly LightGBM: "LightGBM";
    /**
     * XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners.
     */
    readonly XGBoostRegressor: "XGBoostRegressor";
};
/**
 * Enum for all forecasting models supported by AutoML.
 */
export type ForecastingModels = (typeof ForecastingModels)[keyof typeof ForecastingModels];
export declare const ForecastingPrimaryMetrics: {
    /**
     * The Spearman's rank coefficient of correlation is a non-parametric measure of rank correlation.
     */
    readonly SpearmanCorrelation: "SpearmanCorrelation";
    /**
     * The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales.
     */
    readonly NormalizedRootMeanSquaredError: "NormalizedRootMeanSquaredError";
    /**
     * The R2 score is one of the performance evaluation measures for forecasting-based machine learning models.
     */
    readonly R2Score: "R2Score";
    /**
     * The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales.
     */
    readonly NormalizedMeanAbsoluteError: "NormalizedMeanAbsoluteError";
};
/**
 * Primary metric for forecasting task.
 */
export type ForecastingPrimaryMetrics = (typeof ForecastingPrimaryMetrics)[keyof typeof ForecastingPrimaryMetrics];
export declare const Goal: {
    readonly Minimize: "Minimize";
    readonly Maximize: "Maximize";
};
/**
 * [Required] Defines supported metric goals for hyperparameter tuning
 */
export type Goal = (typeof Goal)[keyof typeof Goal];
export declare const IdentityConfigurationType: {
    readonly Managed: "Managed";
    readonly AMLToken: "AMLToken";
    readonly UserIdentity: "UserIdentity";
};
/**
 * [Required] Specifies the type of identity framework.
 */
export type IdentityConfigurationType = (typeof IdentityConfigurationType)[keyof typeof IdentityConfigurationType];
export declare const ImageType: {
    readonly Docker: "docker";
    readonly Azureml: "azureml";
};
/**
 * Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
 */
export type ImageType = (typeof ImageType)[keyof typeof ImageType];
export declare const InputDeliveryMode: {
    readonly ReadOnlyMount: "ReadOnlyMount";
    readonly ReadWriteMount: "ReadWriteMount";
    readonly Download: "Download";
    readonly Direct: "Direct";
    readonly EvalMount: "EvalMount";
    readonly EvalDownload: "EvalDownload";
};
/**
 * Input Asset Delivery Mode.
 */
export type InputDeliveryMode = (typeof InputDeliveryMode)[keyof typeof InputDeliveryMode];
export declare const InstanceSegmentationPrimaryMetrics: {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    readonly MeanAveragePrecision: "MeanAveragePrecision";
};
/**
 * Primary metric to optimize for this task.
 */
export type InstanceSegmentationPrimaryMetrics = (typeof InstanceSegmentationPrimaryMetrics)[keyof typeof InstanceSegmentationPrimaryMetrics];
export declare const IsolationMode: {
    readonly Disabled: "Disabled";
    readonly AllowInternetOutbound: "AllowInternetOutbound";
    readonly AllowOnlyApprovedOutbound: "AllowOnlyApprovedOutbound";
};
/**
 * Isolation mode for the managed network of a machine learning workspace.
 */
export type IsolationMode = (typeof IsolationMode)[keyof typeof IsolationMode];
export declare const JobInputType: {
    readonly Literal: "literal";
    readonly Uri_file: "uri_file";
    readonly Uri_folder: "uri_folder";
    readonly Mltable: "mltable";
    readonly Custom_model: "custom_model";
    readonly Mlflow_model: "mlflow_model";
    readonly Triton_model: "triton_model";
};
/**
 * [Required] Specifies the type of job.
 */
export type JobInputType = (typeof JobInputType)[keyof typeof JobInputType];
export declare const JobLimitsType: {
    readonly Command: "Command";
    readonly Sweep: "Sweep";
};
/**
 * [Required] JobLimit type.
 */
export type JobLimitsType = (typeof JobLimitsType)[keyof typeof JobLimitsType];
export declare const JobOutputType: {
    readonly Uri_file: "uri_file";
    readonly Uri_folder: "uri_folder";
    readonly Mltable: "mltable";
    readonly Custom_model: "custom_model";
    readonly Mlflow_model: "mlflow_model";
    readonly Triton_model: "triton_model";
};
/**
 * [Required] Specifies the type of job.
 */
export type JobOutputType = (typeof JobOutputType)[keyof typeof JobOutputType];
export declare const JobTier: {
    readonly Null: "Null";
    readonly Spot: "Spot";
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Premium: "Premium";
};
/**
 * Controls the compute job tier
 */
export type JobTier = (typeof JobTier)[keyof typeof JobTier];
export declare const JobType: {
    readonly AutoML: "AutoML";
    readonly Command: "Command";
    readonly Sweep: "Sweep";
    readonly Pipeline: "Pipeline";
    readonly Spark: "Spark";
};
/**
 * [Required] Specifies the type of job.
 */
export type JobType = (typeof JobType)[keyof typeof JobType];
export declare const LearningRateScheduler: {
    /**
     * No learning rate scheduler selected.
     */
    readonly None: "None";
    /**
     * Cosine Annealing With Warmup.
     */
    readonly WarmupCosine: "WarmupCosine";
    /**
     * Step learning rate scheduler.
     */
    readonly Step: "Step";
};
/**
 * Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
 */
export type LearningRateScheduler = (typeof LearningRateScheduler)[keyof typeof LearningRateScheduler];
export declare const LoadBalancerType: {
    readonly PublicIp: "PublicIp";
    readonly InternalLoadBalancer: "InternalLoadBalancer";
};
/**
 * Load Balancer Type
 */
export type LoadBalancerType = (typeof LoadBalancerType)[keyof typeof LoadBalancerType];
export declare const LogVerbosity: {
    /**
     * No logs emitted.
     */
    readonly NotSet: "NotSet";
    /**
     * Debug and above log statements logged.
     */
    readonly Debug: "Debug";
    /**
     * Info and above log statements logged.
     */
    readonly Info: "Info";
    /**
     * Warning and above log statements logged.
     */
    readonly Warning: "Warning";
    /**
     * Error and above log statements logged.
     */
    readonly Error: "Error";
    /**
     * Only critical statements logged.
     */
    readonly Critical: "Critical";
};
/**
 * Log verbosity for the job.
 */
export type LogVerbosity = (typeof LogVerbosity)[keyof typeof LogVerbosity];
export declare const ManagedNetworkStatus: {
    readonly Inactive: "Inactive";
    readonly Active: "Active";
};
/**
 * Status for the managed network of a machine learning workspace.
 */
export type ManagedNetworkStatus = (typeof ManagedNetworkStatus)[keyof typeof ManagedNetworkStatus];
export declare const ManagedServiceIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned,UserAssigned";
};
/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const MaterializationStoreType: {
    readonly None: "None";
    readonly Online: "Online";
    readonly Offline: "Offline";
    readonly OnlineAndOffline: "OnlineAndOffline";
};
/**
 * Specifies the stores to which materialization should happen
 */
export type MaterializationStoreType = (typeof MaterializationStoreType)[keyof typeof MaterializationStoreType];
export declare const ModelSize: {
    /**
     * No value selected.
     */
    readonly None: "None";
    /**
     * Small size.
     */
    readonly Small: "Small";
    /**
     * Medium size.
     */
    readonly Medium: "Medium";
    /**
     * Large size.
     */
    readonly Large: "Large";
    /**
     * Extra large size.
     */
    readonly ExtraLarge: "ExtraLarge";
};
/**
 * Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
 * Note: training run may get into CUDA OOM if the model size is too big.
 * Note: This settings is only supported for the 'yolov5' algorithm.
 */
export type ModelSize = (typeof ModelSize)[keyof typeof ModelSize];
export declare const ModelTaskType: {
    readonly Classification: "Classification";
    readonly Regression: "Regression";
};
/**
 * [Required] The machine learning task type of the monitored model.
 */
export type ModelTaskType = (typeof ModelTaskType)[keyof typeof ModelTaskType];
export declare const MonitorComputeIdentityType: {
    /**
     * Authenticates through user's AML token.
     */
    readonly AmlToken: "AmlToken";
    /**
     * Authenticates through a user-provided managed identity.
     */
    readonly ManagedIdentity: "ManagedIdentity";
};
/**
 * [Required] Specifies the type of identity to use within the monitoring jobs.
 */
export type MonitorComputeIdentityType = (typeof MonitorComputeIdentityType)[keyof typeof MonitorComputeIdentityType];
export declare const MonitorComputeType: {
    /**
     * Serverless Spark compute.
     */
    readonly ServerlessSpark: "ServerlessSpark";
};
/**
 * [Required] Specifies the type of signal to monitor.
 */
export type MonitorComputeType = (typeof MonitorComputeType)[keyof typeof MonitorComputeType];
export declare const MonitoringFeatureDataType: {
    /**
     * Used for features of numerical data type.
     */
    readonly Numerical: "Numerical";
    /**
     * Used for features of categorical data type.
     */
    readonly Categorical: "Categorical";
};
/**
 * [Required] Specifies the data type of the metric threshold.
 */
export type MonitoringFeatureDataType = (typeof MonitoringFeatureDataType)[keyof typeof MonitoringFeatureDataType];
export declare const MonitoringFeatureFilterType: {
    /**
     * Includes all features.
     */
    readonly AllFeatures: "AllFeatures";
    /**
     * Only includes the top contributing features, measured by feature attribution.
     */
    readonly TopNByAttribution: "TopNByAttribution";
    /**
     * Includes a user-defined subset of features.
     */
    readonly FeatureSubset: "FeatureSubset";
};
/**
 * [Required] Specifies the feature filter to leverage when selecting features to calculate metrics over.
 */
export type MonitoringFeatureFilterType = (typeof MonitoringFeatureFilterType)[keyof typeof MonitoringFeatureFilterType];
export declare const MonitoringInputDataType: {
    /**
     * An input data with a fixed window size.
     */
    readonly Static: "Static";
    /**
     * An input data which rolls relatively to the monitor's current run time.
     */
    readonly Rolling: "Rolling";
    /**
     * An input data with tabular format which doesn't require preprocessing.
     */
    readonly Fixed: "Fixed";
};
/**
 * [Required] Specifies the type of signal to monitor.
 */
export type MonitoringInputDataType = (typeof MonitoringInputDataType)[keyof typeof MonitoringInputDataType];
export declare const MonitoringNotificationType: {
    /**
     * Enables email notifications through AML notifications.
     */
    readonly AmlNotification: "AmlNotification";
};
export type MonitoringNotificationType = (typeof MonitoringNotificationType)[keyof typeof MonitoringNotificationType];
export declare const MonitoringSignalType: {
    /**
     * Tracks model input data distribution change, comparing against training data or past production data.
     */
    readonly DataDrift: "DataDrift";
    /**
     * Tracks prediction result data distribution change, comparing against validation/test label data or past production data.
     */
    readonly PredictionDrift: "PredictionDrift";
    /**
     * Tracks model input data integrity.
     */
    readonly DataQuality: "DataQuality";
    /**
     * Tracks feature importance change in production, comparing against feature importance at training time.
     */
    readonly FeatureAttributionDrift: "FeatureAttributionDrift";
    /**
     * Tracks a custom signal provided by users.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] Specifies the type of signal to monitor.
 */
export type MonitoringSignalType = (typeof MonitoringSignalType)[keyof typeof MonitoringSignalType];
export declare const NCrossValidationsMode: {
    /**
     * Determine N-Cross validations value automatically. Supported only for 'Forecasting' AutoML task.
     */
    readonly Auto: "Auto";
    /**
     * Use custom N-Cross validations value.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] Mode for determining N-Cross validations.
 */
export type NCrossValidationsMode = (typeof NCrossValidationsMode)[keyof typeof NCrossValidationsMode];
export declare const NodesValueType: {
    readonly All: "All";
};
/**
 * [Required] Type of the Nodes value
 */
export type NodesValueType = (typeof NodesValueType)[keyof typeof NodesValueType];
export declare const NumericalDataDriftMetric: {
    /**
     * The Jensen Shannon Distance (JSD) metric.
     */
    readonly JensenShannonDistance: "JensenShannonDistance";
    /**
     * The Population Stability Index (PSI) metric.
     */
    readonly PopulationStabilityIndex: "PopulationStabilityIndex";
    /**
     * The Normalized Wasserstein Distance metric.
     */
    readonly NormalizedWassersteinDistance: "NormalizedWassersteinDistance";
    /**
     * The Two Sample Kolmogorov-Smirnov Test (two-sample K–S) metric.
     */
    readonly TwoSampleKolmogorovSmirnovTest: "TwoSampleKolmogorovSmirnovTest";
};
/**
 * [Required] The numerical data drift metric to calculate.
 */
export type NumericalDataDriftMetric = (typeof NumericalDataDriftMetric)[keyof typeof NumericalDataDriftMetric];
export declare const NumericalDataQualityMetric: {
    /**
     * Calculates the rate of null values.
     */
    readonly NullValueRate: "NullValueRate";
    /**
     * Calculates the rate of data type errors.
     */
    readonly DataTypeErrorRate: "DataTypeErrorRate";
    /**
     * Calculates the rate values are out of bounds.
     */
    readonly OutOfBoundsRate: "OutOfBoundsRate";
};
/**
 * [Required] The numerical data quality metric to calculate.
 */
export type NumericalDataQualityMetric = (typeof NumericalDataQualityMetric)[keyof typeof NumericalDataQualityMetric];
export declare const NumericalPredictionDriftMetric: {
    /**
     * The Jensen Shannon Distance (JSD) metric.
     */
    readonly JensenShannonDistance: "JensenShannonDistance";
    /**
     * The Population Stability Index (PSI) metric.
     */
    readonly PopulationStabilityIndex: "PopulationStabilityIndex";
    /**
     * The Normalized Wasserstein Distance metric.
     */
    readonly NormalizedWassersteinDistance: "NormalizedWassersteinDistance";
    /**
     * The Two Sample Kolmogorov-Smirnov Test (two-sample K–S) metric.
     */
    readonly TwoSampleKolmogorovSmirnovTest: "TwoSampleKolmogorovSmirnovTest";
};
/**
 * [Required] The numerical prediction drift metric to calculate.
 */
export type NumericalPredictionDriftMetric = (typeof NumericalPredictionDriftMetric)[keyof typeof NumericalPredictionDriftMetric];
export declare const ObjectDetectionPrimaryMetrics: {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    readonly MeanAveragePrecision: "MeanAveragePrecision";
};
/**
 * Primary metric to optimize for this task.
 */
export type ObjectDetectionPrimaryMetrics = (typeof ObjectDetectionPrimaryMetrics)[keyof typeof ObjectDetectionPrimaryMetrics];
export declare const OneLakeArtifactType: {
    readonly LakeHouse: "LakeHouse";
};
/**
 * [Required] OneLake artifact type
 */
export type OneLakeArtifactType = (typeof OneLakeArtifactType)[keyof typeof OneLakeArtifactType];
export declare const OperatingSystemType: {
    readonly Linux: "Linux";
    readonly Windows: "Windows";
};
/**
 * The OS type of the environment.
 */
export type OperatingSystemType = (typeof OperatingSystemType)[keyof typeof OperatingSystemType];
export declare const OsType: {
    readonly Linux: "Linux";
    readonly Windows: "Windows";
};
/**
 * Compute OS Type
 */
export type OsType = (typeof OsType)[keyof typeof OsType];
export declare const OutputDeliveryMode: {
    readonly ReadWriteMount: "ReadWriteMount";
    readonly Upload: "Upload";
    readonly Direct: "Direct";
};
/**
 * Output Asset Delivery Mode.
 */
export type OutputDeliveryMode = (typeof OutputDeliveryMode)[keyof typeof OutputDeliveryMode];
export declare const PrivateEndpointServiceConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
    readonly Timeout: "Timeout";
};
/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];
export declare const Protocol: {
    readonly Tcp: "tcp";
    readonly Udp: "udp";
    readonly Http: "http";
};
/**
 * Protocol over which communication will happen over this endpoint
 */
export type Protocol = (typeof Protocol)[keyof typeof Protocol];
export declare const PublicNetworkAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether requests from Public Network are allowed.
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const PublicNetworkAccessType: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
 */
export type PublicNetworkAccessType = (typeof PublicNetworkAccessType)[keyof typeof PublicNetworkAccessType];
export declare const RandomSamplingAlgorithmRule: {
    readonly Random: "Random";
    readonly Sobol: "Sobol";
};
/**
 * The specific type of random algorithm
 */
export type RandomSamplingAlgorithmRule = (typeof RandomSamplingAlgorithmRule)[keyof typeof RandomSamplingAlgorithmRule];
export declare const RecurrenceFrequency: {
    /**
     * Minute frequency
     */
    readonly Minute: "Minute";
    /**
     * Hour frequency
     */
    readonly Hour: "Hour";
    /**
     * Day frequency
     */
    readonly Day: "Day";
    /**
     * Week frequency
     */
    readonly Week: "Week";
    /**
     * Month frequency
     */
    readonly Month: "Month";
};
/**
 * [Required] The frequency to trigger schedule.
 */
export type RecurrenceFrequency = (typeof RecurrenceFrequency)[keyof typeof RecurrenceFrequency];
export declare const ReferenceType: {
    readonly Id: "Id";
    readonly DataPath: "DataPath";
    readonly OutputPath: "OutputPath";
};
/**
 * [Required] Specifies the type of asset reference.
 */
export type ReferenceType = (typeof ReferenceType)[keyof typeof ReferenceType];
export declare const RegressionModels: {
    /**
     * Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions.
     */
    readonly ElasticNet: "ElasticNet";
    /**
     * The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution.
     */
    readonly GradientBoosting: "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    readonly DecisionTree: "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    readonly KNN: "KNN";
    /**
     * Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer.
     */
    readonly LassoLars: "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    readonly SGD: "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    readonly RandomForest: "RandomForest";
    /**
     * Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm.
     */
    readonly ExtremeRandomTrees: "ExtremeRandomTrees";
    /**
     * LightGBM is a gradient boosting framework that uses tree based learning algorithms.
     */
    readonly LightGBM: "LightGBM";
    /**
     * XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners.
     */
    readonly XGBoostRegressor: "XGBoostRegressor";
};
/**
 * Enum for all Regression models supported by AutoML.
 */
export type RegressionModels = (typeof RegressionModels)[keyof typeof RegressionModels];
export declare const RegressionPrimaryMetrics: {
    /**
     * The Spearman's rank coefficient of correlation is a nonparametric measure of rank correlation.
     */
    readonly SpearmanCorrelation: "SpearmanCorrelation";
    /**
     * The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales.
     */
    readonly NormalizedRootMeanSquaredError: "NormalizedRootMeanSquaredError";
    /**
     * The R2 score is one of the performance evaluation measures for forecasting-based machine learning models.
     */
    readonly R2Score: "R2Score";
    /**
     * The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales.
     */
    readonly NormalizedMeanAbsoluteError: "NormalizedMeanAbsoluteError";
};
/**
 * Primary metric for regression task.
 */
export type RegressionPrimaryMetrics = (typeof RegressionPrimaryMetrics)[keyof typeof RegressionPrimaryMetrics];
export declare const RemoteLoginPortPublicAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
    readonly NotSpecified: "NotSpecified";
};
/**
 * State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
 */
export type RemoteLoginPortPublicAccess = (typeof RemoteLoginPortPublicAccess)[keyof typeof RemoteLoginPortPublicAccess];
export declare const RollingRateType: {
    readonly Year: "Year";
    readonly Month: "Month";
    readonly Day: "Day";
    readonly Hour: "Hour";
    readonly Minute: "Minute";
};
/**
 * When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
 * If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
 * If it's day, all data will be collected in blob path /yyyy/MM/dd/.
 * The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
 */
export type RollingRateType = (typeof RollingRateType)[keyof typeof RollingRateType];
export declare const RuleAction: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The action enum for networking rule.
 */
export type RuleAction = (typeof RuleAction)[keyof typeof RuleAction];
export declare const RuleCategory: {
    readonly Required: "Required";
    readonly Recommended: "Recommended";
    readonly UserDefined: "UserDefined";
    readonly Dependency: "Dependency";
};
/**
 * Category of a managed network Outbound Rule of a machine learning workspace.
 */
export type RuleCategory = (typeof RuleCategory)[keyof typeof RuleCategory];
export declare const RuleStatus: {
    readonly Inactive: "Inactive";
    readonly Active: "Active";
};
/**
 * Type of a managed network Outbound Rule of a machine learning workspace.
 */
export type RuleStatus = (typeof RuleStatus)[keyof typeof RuleStatus];
export declare const RuleType: {
    readonly FQDN: "FQDN";
    readonly PrivateEndpoint: "PrivateEndpoint";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Type of a managed network Outbound Rule of a machine learning workspace.
 */
export type RuleType = (typeof RuleType)[keyof typeof RuleType];
export declare const SamplingAlgorithmType: {
    readonly Grid: "Grid";
    readonly Random: "Random";
    readonly Bayesian: "Bayesian";
};
/**
 * [Required] The algorithm used for generating hyperparameter values, along with configuration properties
 */
export type SamplingAlgorithmType = (typeof SamplingAlgorithmType)[keyof typeof SamplingAlgorithmType];
export declare const ScaleType: {
    readonly Default: "Default";
    readonly TargetUtilization: "TargetUtilization";
};
/**
 * [Required] Type of deployment scaling algorithm
 */
export type ScaleType = (typeof ScaleType)[keyof typeof ScaleType];
export declare const ScheduleActionType: {
    readonly CreateJob: "CreateJob";
    readonly InvokeBatchEndpoint: "InvokeBatchEndpoint";
    readonly CreateMonitor: "CreateMonitor";
};
/**
 * [Required] Specifies the action type of the schedule
 */
export type ScheduleActionType = (typeof ScheduleActionType)[keyof typeof ScheduleActionType];
export declare const ScheduleProvisioningState: {
    readonly Completed: "Completed";
    readonly Provisioning: "Provisioning";
    readonly Failed: "Failed";
};
/**
 * The current deployment state of schedule.
 */
export type ScheduleProvisioningState = (typeof ScheduleProvisioningState)[keyof typeof ScheduleProvisioningState];
export declare const ScheduleStatus: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Is the schedule enabled or disabled?
 */
export type ScheduleStatus = (typeof ScheduleStatus)[keyof typeof ScheduleStatus];
export declare const SeasonalityMode: {
    /**
     * Seasonality to be determined automatically.
     */
    readonly Auto: "Auto";
    /**
     * Use the custom seasonality value.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] Seasonality mode.
 */
export type SeasonalityMode = (typeof SeasonalityMode)[keyof typeof SeasonalityMode];
export declare const SecretsType: {
    readonly AccountKey: "AccountKey";
    readonly Certificate: "Certificate";
    readonly Sas: "Sas";
    readonly ServicePrincipal: "ServicePrincipal";
};
/**
 * [Required] Credential type used to authentication with storage.
 */
export type SecretsType = (typeof SecretsType)[keyof typeof SecretsType];
export declare const ServerlessInferenceEndpointAuthMode: {
    readonly Key: "Key";
};
/**
 * [Required] Specifies the authentication mode for the Serverless endpoint.
 */
export type ServerlessInferenceEndpointAuthMode = (typeof ServerlessInferenceEndpointAuthMode)[keyof typeof ServerlessInferenceEndpointAuthMode];
export declare const ServiceDataAccessAuthIdentity: {
    /**
     * Do not use any identity for service data access.
     */
    readonly None: "None";
    /**
     * Use the system assigned managed identity of the Workspace to authenticate service data access.
     */
    readonly WorkspaceSystemAssignedIdentity: "WorkspaceSystemAssignedIdentity";
    /**
     * Use the user assigned managed identity of the Workspace to authenticate service data access.
     */
    readonly WorkspaceUserAssignedIdentity: "WorkspaceUserAssignedIdentity";
};
/**
 * Indicates which identity to use to authenticate service data access to customer's storage.
 */
export type ServiceDataAccessAuthIdentity = (typeof ServiceDataAccessAuthIdentity)[keyof typeof ServiceDataAccessAuthIdentity];
export declare const ShortSeriesHandlingConfiguration: {
    /**
     * Represents no/null value.
     */
    readonly None: "None";
    /**
     * Short series will be padded if there are no long series, otherwise short series will be dropped.
     */
    readonly Auto: "Auto";
    /**
     * All the short series will be padded.
     */
    readonly Pad: "Pad";
    /**
     * All the short series will be dropped.
     */
    readonly Drop: "Drop";
};
/**
 * The parameter defining how if AutoML should handle short time series.
 */
export type ShortSeriesHandlingConfiguration = (typeof ShortSeriesHandlingConfiguration)[keyof typeof ShortSeriesHandlingConfiguration];
export declare const SkuTier: {
    readonly Free: "Free";
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Premium: "Premium";
};
/**
 * This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
 */
export type SkuTier = (typeof SkuTier)[keyof typeof SkuTier];
export declare const SparkJobEntryType: {
    readonly SparkJobPythonEntry: "SparkJobPythonEntry";
    readonly SparkJobScalaEntry: "SparkJobScalaEntry";
};
/**
 * [Required] Type of the job's entry point.
 */
export type SparkJobEntryType = (typeof SparkJobEntryType)[keyof typeof SparkJobEntryType];
export declare const SshPublicAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
 */
export type SshPublicAccess = (typeof SshPublicAccess)[keyof typeof SshPublicAccess];
export declare const SslConfigStatus: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
    readonly Auto: "Auto";
};
/**
 * Enable or disable ssl for scoring
 */
export type SslConfigStatus = (typeof SslConfigStatus)[keyof typeof SslConfigStatus];
export declare const StackMetaLearnerType: {
    readonly None: "None";
    /**
     * Default meta-learners are LogisticRegression for classification tasks.
     */
    readonly LogisticRegression: "LogisticRegression";
    /**
     * Default meta-learners are LogisticRegression for classification task when CV is on.
     */
    readonly LogisticRegressionCV: "LogisticRegressionCV";
    readonly LightGBMClassifier: "LightGBMClassifier";
    /**
     * Default meta-learners are LogisticRegression for regression task.
     */
    readonly ElasticNet: "ElasticNet";
    /**
     * Default meta-learners are LogisticRegression for regression task when CV is on.
     */
    readonly ElasticNetCV: "ElasticNetCV";
    readonly LightGBMRegressor: "LightGBMRegressor";
    readonly LinearRegression: "LinearRegression";
};
/**
 * The meta-learner is a model trained on the output of the individual heterogeneous models.
 */
export type StackMetaLearnerType = (typeof StackMetaLearnerType)[keyof typeof StackMetaLearnerType];
export declare const StochasticOptimizer: {
    /**
     * No optimizer selected.
     */
    readonly None: "None";
    /**
     * Stochastic Gradient Descent optimizer.
     */
    readonly Sgd: "Sgd";
    /**
     * Adam is algorithm the optimizes stochastic objective functions based on adaptive estimates of moments
     */
    readonly Adam: "Adam";
    /**
     * AdamW is a variant of the optimizer Adam that has an improved implementation of weight decay.
     */
    readonly Adamw: "Adamw";
};
/**
 * Type of optimizer.
 */
export type StochasticOptimizer = (typeof StochasticOptimizer)[keyof typeof StochasticOptimizer];
export declare const TargetAggregationFunction: {
    /**
     * Represent no value set.
     */
    readonly None: "None";
    readonly Sum: "Sum";
    readonly Max: "Max";
    readonly Min: "Min";
    readonly Mean: "Mean";
};
/**
 * The function to be used to aggregate the time series target column to conform to a user specified frequency.
 * If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
 */
export type TargetAggregationFunction = (typeof TargetAggregationFunction)[keyof typeof TargetAggregationFunction];
export declare const TargetLagsMode: {
    /**
     * Target lags to be determined automatically.
     */
    readonly Auto: "Auto";
    /**
     * Use the custom target lags.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] Set target lags mode - Auto/Custom
 */
export type TargetLagsMode = (typeof TargetLagsMode)[keyof typeof TargetLagsMode];
export declare const TargetRollingWindowSizeMode: {
    /**
     * Determine rolling windows size automatically.
     */
    readonly Auto: "Auto";
    /**
     * Use the specified rolling window size.
     */
    readonly Custom: "Custom";
};
/**
 * [Required] TargetRollingWindowSiz detection mode.
 */
export type TargetRollingWindowSizeMode = (typeof TargetRollingWindowSizeMode)[keyof typeof TargetRollingWindowSizeMode];
export declare const TaskType: {
    /**
     * Classification in machine learning and statistics is a supervised learning approach in which
     * the computer program learns from the data given to it and make new observations or classifications.
     */
    readonly Classification: "Classification";
    /**
     * Regression means to predict the value using the input data. Regression models are used to predict a continuous value.
     */
    readonly Regression: "Regression";
    /**
     * Forecasting is a special kind of regression task that deals with time-series data and creates forecasting model
     * that can be used to predict the near future values based on the inputs.
     */
    readonly Forecasting: "Forecasting";
    /**
     * Image Classification. Multi-class image classification is used when an image is classified with only a single label
     * from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
     */
    readonly ImageClassification: "ImageClassification";
    /**
     * Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
     * from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
     */
    readonly ImageClassificationMultilabel: "ImageClassificationMultilabel";
    /**
     * Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
     * bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
     */
    readonly ImageObjectDetection: "ImageObjectDetection";
    /**
     * Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
     * drawing a polygon around each object in the image.
     */
    readonly ImageInstanceSegmentation: "ImageInstanceSegmentation";
    /**
     * Text classification (also known as text tagging or text categorization) is the process of sorting texts into categories.
     * Categories are mutually exclusive.
     */
    readonly TextClassification: "TextClassification";
    /**
     * Multilabel classification task assigns each sample to a group (zero or more) of target labels.
     */
    readonly TextClassificationMultilabel: "TextClassificationMultilabel";
    /**
     * Text Named Entity Recognition a.k.a. TextNER.
     * Named Entity Recognition (NER) is the ability to take free-form text and identify the occurrences of entities such as people, locations, organizations, and more.
     */
    readonly TextNER: "TextNER";
};
/**
 * [Required] Task type for AutoMLJob.
 */
export type TaskType = (typeof TaskType)[keyof typeof TaskType];
export declare const TriggerType: {
    readonly Recurrence: "Recurrence";
    readonly Cron: "Cron";
};
/**
 * [Required]
 */
export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType];
export declare const UseStl: {
    /**
     * No stl decomposition.
     */
    readonly None: "None";
    readonly Season: "Season";
    readonly SeasonTrend: "SeasonTrend";
};
/**
 * Configure STL Decomposition of the time-series target column.
 */
export type UseStl = (typeof UseStl)[keyof typeof UseStl];
export declare const ValidationMetricType: {
    /**
     * No metric.
     */
    readonly None: "None";
    /**
     * Coco metric.
     */
    readonly Coco: "Coco";
    /**
     * Voc metric.
     */
    readonly Voc: "Voc";
    /**
     * CocoVoc metric.
     */
    readonly CocoVoc: "CocoVoc";
};
/**
 * Metric computation method to use for validation metrics.
 */
export type ValidationMetricType = (typeof ValidationMetricType)[keyof typeof ValidationMetricType];
export declare const ValueFormat: {
    readonly JSON: "JSON";
};
/**
 * format for the workspace connection value
 */
export type ValueFormat = (typeof ValueFormat)[keyof typeof ValueFormat];
export declare const VmPriority: {
    readonly Dedicated: "Dedicated";
    readonly LowPriority: "LowPriority";
};
/**
 * Virtual Machine priority
 */
export type VmPriority = (typeof VmPriority)[keyof typeof VmPriority];
export declare const VolumeDefinitionType: {
    readonly Bind: "bind";
    readonly Volume: "volume";
    readonly Tmpfs: "tmpfs";
    readonly Npipe: "npipe";
};
/**
 * Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
 */
export type VolumeDefinitionType = (typeof VolumeDefinitionType)[keyof typeof VolumeDefinitionType];
export declare const WebhookType: {
    readonly AzureDevOps: "AzureDevOps";
};
/**
 * [Required] Specifies the type of service to send a callback
 */
export type WebhookType = (typeof WebhookType)[keyof typeof WebhookType];
export declare const WeekDay: {
    /**
     * Monday weekday
     */
    readonly Monday: "Monday";
    /**
     * Tuesday weekday
     */
    readonly Tuesday: "Tuesday";
    /**
     * Wednesday weekday
     */
    readonly Wednesday: "Wednesday";
    /**
     * Thursday weekday
     */
    readonly Thursday: "Thursday";
    /**
     * Friday weekday
     */
    readonly Friday: "Friday";
    /**
     * Saturday weekday
     */
    readonly Saturday: "Saturday";
    /**
     * Sunday weekday
     */
    readonly Sunday: "Sunday";
};
/**
 * Enum of weekday
 */
export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay];
