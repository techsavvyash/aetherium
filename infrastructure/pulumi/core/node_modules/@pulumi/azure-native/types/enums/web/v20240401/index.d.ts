export declare const AuthType: {
    readonly Anonymous: "Anonymous";
    readonly UserCredentials: "UserCredentials";
    readonly SystemIdentity: "SystemIdentity";
    readonly UserAssigned: "UserAssigned";
};
/**
 * Auth Type
 */
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
export declare const AuthenticationType: {
    readonly SystemAssignedIdentity: "SystemAssignedIdentity";
    readonly UserAssignedIdentity: "UserAssignedIdentity";
    readonly StorageAccountConnectionString: "StorageAccountConnectionString";
};
/**
 * Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
 */
export type AuthenticationType = (typeof AuthenticationType)[keyof typeof AuthenticationType];
export declare const AutoGeneratedDomainNameLabelScope: {
    readonly TenantReuse: "TenantReuse";
    readonly SubscriptionReuse: "SubscriptionReuse";
    readonly ResourceGroupReuse: "ResourceGroupReuse";
    readonly NoReuse: "NoReuse";
};
/**
 * Specifies the scope of uniqueness for the default hostname during resource creation
 */
export type AutoGeneratedDomainNameLabelScope = (typeof AutoGeneratedDomainNameLabelScope)[keyof typeof AutoGeneratedDomainNameLabelScope];
export declare const AutoHealActionType: {
    readonly Recycle: "Recycle";
    readonly LogEvent: "LogEvent";
    readonly CustomAction: "CustomAction";
};
/**
 * Predefined action to be taken.
 */
export type AutoHealActionType = (typeof AutoHealActionType)[keyof typeof AutoHealActionType];
export declare const AzureResourceType: {
    readonly Website: "Website";
    readonly TrafficManager: "TrafficManager";
};
/**
 * Azure resource type.
 */
export type AzureResourceType = (typeof AzureResourceType)[keyof typeof AzureResourceType];
export declare const AzureStorageProtocol: {
    readonly Smb: "Smb";
    readonly Http: "Http";
    readonly Nfs: "Nfs";
};
/**
 * Mounting protocol to use for the storage account.
 */
export type AzureStorageProtocol = (typeof AzureStorageProtocol)[keyof typeof AzureStorageProtocol];
export declare const AzureStorageType: {
    readonly AzureFiles: "AzureFiles";
    readonly AzureBlob: "AzureBlob";
};
/**
 * Type of storage.
 */
export type AzureStorageType = (typeof AzureStorageType)[keyof typeof AzureStorageType];
export declare const BuiltInAuthenticationProvider: {
    readonly AzureActiveDirectory: "AzureActiveDirectory";
    readonly Facebook: "Facebook";
    readonly Google: "Google";
    readonly MicrosoftAccount: "MicrosoftAccount";
    readonly Twitter: "Twitter";
    readonly Github: "Github";
};
/**
 * The default authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the unauthenticated client
 * action is set to "RedirectToLoginPage".
 */
export type BuiltInAuthenticationProvider = (typeof BuiltInAuthenticationProvider)[keyof typeof BuiltInAuthenticationProvider];
export declare const ClientCertMode: {
    readonly Required: "Required";
    readonly Optional: "Optional";
    readonly OptionalInteractiveUser: "OptionalInteractiveUser";
};
/**
 * This composes with ClientCertEnabled setting.
 * - ClientCertEnabled: false means ClientCert is ignored.
 * - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
 * - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
 */
export type ClientCertMode = (typeof ClientCertMode)[keyof typeof ClientCertMode];
export declare const ClientCredentialMethod: {
    readonly ClientSecretPost: "ClientSecretPost";
};
/**
 * The method that should be used to authenticate the user.
 */
export type ClientCredentialMethod = (typeof ClientCredentialMethod)[keyof typeof ClientCredentialMethod];
export declare const ConnectionStringType: {
    readonly MySql: "MySql";
    readonly SQLServer: "SQLServer";
    readonly SQLAzure: "SQLAzure";
    readonly Custom: "Custom";
    readonly NotificationHub: "NotificationHub";
    readonly ServiceBus: "ServiceBus";
    readonly EventHub: "EventHub";
    readonly ApiHub: "ApiHub";
    readonly DocDb: "DocDb";
    readonly RedisCache: "RedisCache";
    readonly PostgreSQL: "PostgreSQL";
};
/**
 * Type of database.
 */
export type ConnectionStringType = (typeof ConnectionStringType)[keyof typeof ConnectionStringType];
export declare const CookieExpirationConvention: {
    readonly FixedTime: "FixedTime";
    readonly IdentityProviderDerived: "IdentityProviderDerived";
};
/**
 * The convention used when determining the session cookie's expiration.
 */
export type CookieExpirationConvention = (typeof CookieExpirationConvention)[keyof typeof CookieExpirationConvention];
export declare const CustomHostNameDnsRecordType: {
    readonly CName: "CName";
    readonly A: "A";
};
/**
 * Custom DNS record type.
 */
export type CustomHostNameDnsRecordType = (typeof CustomHostNameDnsRecordType)[keyof typeof CustomHostNameDnsRecordType];
export declare const DaprLogLevel: {
    readonly Info: "info";
    readonly Debug: "debug";
    readonly Warn: "warn";
    readonly Error: "error";
};
/**
 * Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
 */
export type DaprLogLevel = (typeof DaprLogLevel)[keyof typeof DaprLogLevel];
export declare const DatabaseType: {
    readonly SqlAzure: "SqlAzure";
    readonly MySql: "MySql";
    readonly LocalMySql: "LocalMySql";
    readonly PostgreSql: "PostgreSql";
};
/**
 * Database type (e.g. SqlAzure / MySql).
 */
export type DatabaseType = (typeof DatabaseType)[keyof typeof DatabaseType];
export declare const DefaultAction: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * Default action for scm access restriction if no rules are matched.
 */
export type DefaultAction = (typeof DefaultAction)[keyof typeof DefaultAction];
export declare const EnterpriseGradeCdnStatus: {
    readonly Enabled: "Enabled";
    readonly Enabling: "Enabling";
    readonly Disabled: "Disabled";
    readonly Disabling: "Disabling";
};
/**
 * State indicating the status of the enterprise grade CDN serving traffic to the static web app.
 */
export type EnterpriseGradeCdnStatus = (typeof EnterpriseGradeCdnStatus)[keyof typeof EnterpriseGradeCdnStatus];
export declare const ForwardProxyConvention: {
    readonly NoProxy: "NoProxy";
    readonly Standard: "Standard";
    readonly Custom: "Custom";
};
/**
 * The convention used to determine the url of the request made.
 */
export type ForwardProxyConvention = (typeof ForwardProxyConvention)[keyof typeof ForwardProxyConvention];
export declare const FrequencyUnit: {
    readonly Day: "Day";
    readonly Hour: "Hour";
};
/**
 * The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
 */
export type FrequencyUnit = (typeof FrequencyUnit)[keyof typeof FrequencyUnit];
export declare const FrontEndServiceType: {
    readonly NodePort: "NodePort";
    readonly LoadBalancer: "LoadBalancer";
};
export type FrontEndServiceType = (typeof FrontEndServiceType)[keyof typeof FrontEndServiceType];
export declare const FtpsState: {
    readonly AllAllowed: "AllAllowed";
    readonly FtpsOnly: "FtpsOnly";
    readonly Disabled: "Disabled";
};
/**
 * State of FTP / FTPS service
 */
export type FtpsState = (typeof FtpsState)[keyof typeof FtpsState];
export declare const FunctionsDeploymentStorageType: {
    readonly BlobContainer: "blobContainer";
};
/**
 * Property to select Azure Storage type. Available options: blobContainer.
 */
export type FunctionsDeploymentStorageType = (typeof FunctionsDeploymentStorageType)[keyof typeof FunctionsDeploymentStorageType];
export declare const HostNameType: {
    readonly Verified: "Verified";
    readonly Managed: "Managed";
};
/**
 * Hostname type.
 */
export type HostNameType = (typeof HostNameType)[keyof typeof HostNameType];
export declare const HostType: {
    readonly Standard: "Standard";
    readonly Repository: "Repository";
};
/**
 * Indicates whether the hostname is a standard or repository hostname.
 */
export type HostType = (typeof HostType)[keyof typeof HostType];
export declare const IPMode: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
    readonly IPv4AndIPv6: "IPv4AndIPv6";
};
/**
 * Specifies the IP mode of the app.
 */
export type IPMode = (typeof IPMode)[keyof typeof IPMode];
export declare const IpFilterTag: {
    readonly Default: "Default";
    readonly XffProxy: "XffProxy";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
 */
export type IpFilterTag = (typeof IpFilterTag)[keyof typeof IpFilterTag];
export declare const LoadBalancingMode: {
    readonly None: "None";
    readonly Web: "Web";
    readonly Publishing: "Publishing";
    readonly Web_Publishing: "Web, Publishing";
};
/**
 * Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment.
 */
export type LoadBalancingMode = (typeof LoadBalancingMode)[keyof typeof LoadBalancingMode];
export declare const LogLevel: {
    readonly Off: "Off";
    readonly Verbose: "Verbose";
    readonly Information: "Information";
    readonly Warning: "Warning";
    readonly Error: "Error";
};
/**
 * Log level.
 */
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
export declare const ManagedPipelineMode: {
    readonly Integrated: "Integrated";
    readonly Classic: "Classic";
};
/**
 * Managed pipeline mode.
 */
export type ManagedPipelineMode = (typeof ManagedPipelineMode)[keyof typeof ManagedPipelineMode];
export declare const ManagedServiceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * Type of managed service identity.
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const PublicCertificateLocation: {
    readonly CurrentUserMy: "CurrentUserMy";
    readonly LocalMachineMy: "LocalMachineMy";
    readonly Unknown: "Unknown";
};
/**
 * Public Certificate Location
 */
export type PublicCertificateLocation = (typeof PublicCertificateLocation)[keyof typeof PublicCertificateLocation];
export declare const RedundancyMode: {
    readonly None: "None";
    readonly Manual: "Manual";
    readonly Failover: "Failover";
    readonly ActiveActive: "ActiveActive";
    readonly GeoRedundant: "GeoRedundant";
};
/**
 * Site redundancy mode
 */
export type RedundancyMode = (typeof RedundancyMode)[keyof typeof RedundancyMode];
export declare const RouteType: {
    readonly DEFAULT: "DEFAULT";
    readonly INHERITED: "INHERITED";
    readonly STATIC: "STATIC";
};
/**
 * The type of route this is:
 * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
 * INHERITED - Routes inherited from the real Virtual Network routes
 * STATIC - Static route set on the app only
 *
 * These values will be used for syncing an app's routes with those from a Virtual Network.
 */
export type RouteType = (typeof RouteType)[keyof typeof RouteType];
export declare const RuntimeName: {
    readonly Dotnet_isolated: "dotnet-isolated";
    readonly Node: "node";
    readonly Java: "java";
    readonly Powershell: "powershell";
    readonly Python: "python";
    readonly Custom: "custom";
};
/**
 * Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
 */
export type RuntimeName = (typeof RuntimeName)[keyof typeof RuntimeName];
export declare const ScmType: {
    readonly None: "None";
    readonly Dropbox: "Dropbox";
    readonly Tfs: "Tfs";
    readonly LocalGit: "LocalGit";
    readonly GitHub: "GitHub";
    readonly CodePlexGit: "CodePlexGit";
    readonly CodePlexHg: "CodePlexHg";
    readonly BitbucketGit: "BitbucketGit";
    readonly BitbucketHg: "BitbucketHg";
    readonly ExternalGit: "ExternalGit";
    readonly ExternalHg: "ExternalHg";
    readonly OneDrive: "OneDrive";
    readonly VSO: "VSO";
    readonly VSTSRM: "VSTSRM";
};
/**
 * SCM type.
 */
export type ScmType = (typeof ScmType)[keyof typeof ScmType];
export declare const SiteLoadBalancing: {
    readonly WeightedRoundRobin: "WeightedRoundRobin";
    readonly LeastRequests: "LeastRequests";
    readonly LeastResponseTime: "LeastResponseTime";
    readonly WeightedTotalTraffic: "WeightedTotalTraffic";
    readonly RequestHash: "RequestHash";
    readonly PerSiteRoundRobin: "PerSiteRoundRobin";
    readonly LeastRequestsWithTieBreaker: "LeastRequestsWithTieBreaker";
};
/**
 * Site load balancing.
 */
export type SiteLoadBalancing = (typeof SiteLoadBalancing)[keyof typeof SiteLoadBalancing];
export declare const SslState: {
    readonly Disabled: "Disabled";
    readonly SniEnabled: "SniEnabled";
    readonly IpBasedEnabled: "IpBasedEnabled";
};
/**
 * SSL type.
 */
export type SslState = (typeof SslState)[keyof typeof SslState];
export declare const StagingEnvironmentPolicy: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * State indicating whether staging environments are allowed or not allowed for a static web app.
 */
export type StagingEnvironmentPolicy = (typeof StagingEnvironmentPolicy)[keyof typeof StagingEnvironmentPolicy];
export declare const StorageType: {
    readonly LocalNode: "LocalNode";
    readonly NetworkFileSystem: "NetworkFileSystem";
};
export type StorageType = (typeof StorageType)[keyof typeof StorageType];
export declare const SupportedTlsVersions: {
    readonly SupportedTlsVersions_1_0: "1.0";
    readonly SupportedTlsVersions_1_1: "1.1";
    readonly SupportedTlsVersions_1_2: "1.2";
    readonly SupportedTlsVersions_1_3: "1.3";
};
/**
 * ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
 */
export type SupportedTlsVersions = (typeof SupportedTlsVersions)[keyof typeof SupportedTlsVersions];
export declare const TlsCipherSuites: {
    readonly TLS_AES_256_GCM_SHA384: "TLS_AES_256_GCM_SHA384";
    readonly TLS_AES_128_GCM_SHA256: "TLS_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_AES_256_GCM_SHA384: "TLS_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_RSA_WITH_AES_128_GCM_SHA256: "TLS_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA256: "TLS_RSA_WITH_AES_256_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA256: "TLS_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA: "TLS_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA: "TLS_RSA_WITH_AES_128_CBC_SHA";
};
/**
 * The minimum strength TLS cipher suite allowed for an application
 */
export type TlsCipherSuites = (typeof TlsCipherSuites)[keyof typeof TlsCipherSuites];
export declare const UnauthenticatedClientAction: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientAction = (typeof UnauthenticatedClientAction)[keyof typeof UnauthenticatedClientAction];
export declare const UnauthenticatedClientActionV2: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
    readonly Return401: "Return401";
    readonly Return403: "Return403";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientActionV2 = (typeof UnauthenticatedClientActionV2)[keyof typeof UnauthenticatedClientActionV2];
export declare const UpgradePreference: {
    /**
     * No preference on when this App Service Environment will be upgraded
     */
    readonly None: "None";
    /**
     * This App Service Environment will be upgraded before others in the same region that have Upgrade Preference 'Late'
     */
    readonly Early: "Early";
    /**
     * This App Service Environment will be upgraded after others in the same region that have Upgrade Preference 'Early'
     */
    readonly Late: "Late";
    /**
     * ASEv3 only. Once an upgrade is available, this App Service Environment will wait 10 days for the upgrade to be manually initiated. After 10 days the upgrade will begin automatically
     */
    readonly Manual: "Manual";
};
/**
 * Upgrade Preference
 */
export type UpgradePreference = (typeof UpgradePreference)[keyof typeof UpgradePreference];
