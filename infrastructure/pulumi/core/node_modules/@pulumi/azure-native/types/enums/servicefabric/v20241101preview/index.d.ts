export declare const Access: {
    /**
     * The network traffic is allowed.
     */
    readonly Allow: "allow";
    /**
     * The network traffic is denied.
     */
    readonly Deny: "deny";
};
/**
 * The network traffic is allowed or denied.
 */
export type Access = (typeof Access)[keyof typeof Access];
export declare const AutoGeneratedDomainNameLabelScope: {
    /**
     * TenantReuse allows for the same hash to be created if the resource is created in the same Tenant with the same resource name.
     */
    readonly TenantReuse: "TenantReuse";
    /**
     * SubscriptionReuse allows for the same hash to be created if the resource is created in the same Subscription with the same resource name.
     */
    readonly SubscriptionReuse: "SubscriptionReuse";
    /**
     * ResourceGroupReuse allows for the same hash to be created if the resource is created in the same Resource Group with the same resource name.
     */
    readonly ResourceGroupReuse: "ResourceGroupReuse";
    /**
     * NoReuse will create a new hash regardless of the Subscription, Resource Group, Tenant and Resource name.
     */
    readonly NoReuse: "NoReuse";
};
/**
 * This property is the entry point to using a public CA cert for your cluster cert. It specifies the level of reuse allowed for the custom FQDN created, matching the subject of the public CA cert.
 */
export type AutoGeneratedDomainNameLabelScope = (typeof AutoGeneratedDomainNameLabelScope)[keyof typeof AutoGeneratedDomainNameLabelScope];
export declare const ClusterUpgradeCadence: {
    /**
     * Cluster upgrade starts immediately after a new version is rolled out. Recommended for Test/Dev clusters.
     */
    readonly Wave0: "Wave0";
    /**
     * Cluster upgrade starts 7 days after a new version is rolled out. Recommended for Pre-prod clusters.
     */
    readonly Wave1: "Wave1";
    /**
     * Cluster upgrade starts 14 days after a new version is rolled out. Recommended for Production clusters.
     */
    readonly Wave2: "Wave2";
};
/**
 * Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when **clusterUpgradeMode** is set to 'Automatic'.
 */
export type ClusterUpgradeCadence = (typeof ClusterUpgradeCadence)[keyof typeof ClusterUpgradeCadence];
export declare const ClusterUpgradeMode: {
    /**
     * The cluster will be automatically upgraded to the latest Service Fabric runtime version, **clusterUpgradeCadence** will determine when the upgrade starts after the new version becomes available.
     */
    readonly Automatic: "Automatic";
    /**
     * The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
     */
    readonly Manual: "Manual";
};
/**
 * The upgrade mode of the cluster when new Service Fabric runtime version is available.
 */
export type ClusterUpgradeMode = (typeof ClusterUpgradeMode)[keyof typeof ClusterUpgradeMode];
export declare const Direction: {
    /**
     * Inbound direction.
     */
    readonly Inbound: "inbound";
    /**
     * Outbound direction.
     */
    readonly Outbound: "outbound";
};
/**
 * Network security rule direction.
 */
export type Direction = (typeof Direction)[keyof typeof Direction];
export declare const DiskType: {
    /**
     * Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access.
     */
    readonly Standard_LRS: "Standard_LRS";
    /**
     * Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test.
     */
    readonly StandardSSD_LRS: "StandardSSD_LRS";
    /**
     * Premium SSD locally redundant storage. Best for production and performance sensitive workloads.
     */
    readonly Premium_LRS: "Premium_LRS";
    /**
     * Premium SSD V2 locally redundant storage. Best for production and performance sensitive workloads that consistently require low latency and high IOPS and throughput.
     */
    readonly PremiumV2_LRS: "PremiumV2_LRS";
    /**
     * Standard SSD zone redundant storage. Best for web servers, lightly used enterprise applications and dev/test that need storage resiliency against zone failures.
     */
    readonly StandardSSD_ZRS: "StandardSSD_ZRS";
    /**
     * Premium SSD zone redundant storage. Best for production workloads that need storage resiliency against zone failures.
     */
    readonly Premium_ZRS: "Premium_ZRS";
};
/**
 * Managed data disk type. Specifies the storage account type for the managed disk
 */
export type DiskType = (typeof DiskType)[keyof typeof DiskType];
export declare const EvictionPolicyType: {
    /**
     * Eviction policy will be Delete for SPOT vms.
     */
    readonly Delete: "Delete";
    /**
     * Eviction policy will be Deallocate for SPOT vms.
     */
    readonly Deallocate: "Deallocate";
};
/**
 * Specifies the eviction policy for virtual machines in a SPOT node type. Default is Delete.
 */
export type EvictionPolicyType = (typeof EvictionPolicyType)[keyof typeof EvictionPolicyType];
export declare const FailureAction: {
    /**
     * Indicates that a rollback of the upgrade will be performed by Service Fabric if the upgrade fails.
     */
    readonly Rollback: "Rollback";
    /**
     * Indicates that a manual repair will need to be performed by the administrator if the upgrade fails. Service Fabric will not proceed to the next upgrade domain automatically.
     */
    readonly Manual: "Manual";
};
/**
 * The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
 */
export type FailureAction = (typeof FailureAction)[keyof typeof FailureAction];
export declare const IPAddressType: {
    /**
     * IPv4 address type.
     */
    readonly IPv4: "IPv4";
    /**
     * IPv6 address type.
     */
    readonly IPv6: "IPv6";
};
/**
 * The IP address type of this frontend configuration. If omitted the default value is IPv4.
 */
export type IPAddressType = (typeof IPAddressType)[keyof typeof IPAddressType];
export declare const ManagedClusterAddOnFeature: {
    /**
     * Dns service
     */
    readonly DnsService: "DnsService";
    /**
     * Backup and restore service
     */
    readonly BackupRestoreService: "BackupRestoreService";
    /**
     * Resource monitor service
     */
    readonly ResourceMonitorService: "ResourceMonitorService";
};
/**
 * Available cluster add-on features
 */
export type ManagedClusterAddOnFeature = (typeof ManagedClusterAddOnFeature)[keyof typeof ManagedClusterAddOnFeature];
export declare const ManagedIdentityType: {
    /**
     * Indicates that no identity is associated with the resource.
     */
    readonly None: "None";
    /**
     * Indicates that system assigned identity is associated with the resource.
     */
    readonly SystemAssigned: "SystemAssigned";
    /**
     * Indicates that user assigned identity is associated with the resource.
     */
    readonly UserAssigned: "UserAssigned";
    /**
     * Indicates that both system assigned and user assigned identity are associated with the resource.
     */
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
};
/**
 * The type of managed identity for the resource.
 */
export type ManagedIdentityType = (typeof ManagedIdentityType)[keyof typeof ManagedIdentityType];
export declare const MoveCost: {
    /**
     * Zero move cost. This value is zero.
     */
    readonly Zero: "Zero";
    /**
     * Specifies the move cost of the service as Low. The value is 1.
     */
    readonly Low: "Low";
    /**
     * Specifies the move cost of the service as Medium. The value is 2.
     */
    readonly Medium: "Medium";
    /**
     * Specifies the move cost of the service as High. The value is 3.
     */
    readonly High: "High";
};
/**
 * Specifies the move cost for the service.
 */
export type MoveCost = (typeof MoveCost)[keyof typeof MoveCost];
export declare const NsgProtocol: {
    /**
     * Protocol applies to HTTP.
     */
    readonly Http: "http";
    /**
     * Protocol applies to HTTPS.
     */
    readonly Https: "https";
    /**
     * Protocol applies to TCP.
     */
    readonly Tcp: "tcp";
    /**
     * Protocol applies to UDP.
     */
    readonly Udp: "udp";
    /**
     * Protocol applies to ICMP.
     */
    readonly Icmp: "icmp";
    /**
     * Protocol applies to AH.
     */
    readonly Ah: "ah";
    /**
     * Protocol applies to ESP.
     */
    readonly Esp: "esp";
};
/**
 * Network protocol this rule applies to.
 */
export type NsgProtocol = (typeof NsgProtocol)[keyof typeof NsgProtocol];
export declare const PartitionScheme: {
    /**
     * Indicates that the partition is based on string names, and is a SingletonPartitionScheme object, The value is 0.
     */
    readonly Singleton: "Singleton";
    /**
     * Indicates that the partition is based on Int64 key ranges, and is a UniformInt64RangePartitionScheme object. The value is 1.
     */
    readonly UniformInt64Range: "UniformInt64Range";
    /**
     * Indicates that the partition is based on string names, and is a NamedPartitionScheme object. The value is 2.
     */
    readonly Named: "Named";
};
/**
 * Enumerates the ways that a service can be partitioned.
 */
export type PartitionScheme = (typeof PartitionScheme)[keyof typeof PartitionScheme];
export declare const PrivateEndpointNetworkPolicies: {
    /**
     * Enable apply network policies on private end point in the subnet.
     */
    readonly Enabled: "enabled";
    /**
     * Disable apply network policies on private end point in the subnet.
     */
    readonly Disabled: "disabled";
};
/**
 * Enable or Disable apply network policies on private end point in the subnet.
 */
export type PrivateEndpointNetworkPolicies = (typeof PrivateEndpointNetworkPolicies)[keyof typeof PrivateEndpointNetworkPolicies];
export declare const PrivateIPAddressVersion: {
    /**
     * The IP configuration's private IP is IPv4.
     */
    readonly IPv4: "IPv4";
    /**
     * The IP configuration's private IP is IPv6.
     */
    readonly IPv6: "IPv6";
};
/**
 * Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
 */
export type PrivateIPAddressVersion = (typeof PrivateIPAddressVersion)[keyof typeof PrivateIPAddressVersion];
export declare const PrivateLinkServiceNetworkPolicies: {
    /**
     * Enable apply network policies on private link service in the subnet.
     */
    readonly Enabled: "enabled";
    /**
     * Disable apply network policies on private link service in the subnet.
     */
    readonly Disabled: "disabled";
};
/**
 * Enable or Disable apply network policies on private link service in the subnet.
 */
export type PrivateLinkServiceNetworkPolicies = (typeof PrivateLinkServiceNetworkPolicies)[keyof typeof PrivateLinkServiceNetworkPolicies];
export declare const ProbeProtocol: {
    /**
     * Probe protocol is TCP.
     */
    readonly Tcp: "tcp";
    /**
     * Probe protocol is HTTP.
     */
    readonly Http: "http";
    /**
     * Probe protocol is HTTPS.
     */
    readonly Https: "https";
};
/**
 * the reference to the load balancer probe used by the load balancing rule.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const Protocol: {
    /**
     * Transport protocol is TCP.
     */
    readonly Tcp: "tcp";
    /**
     * Transport protocol is UDP.
     */
    readonly Udp: "udp";
};
/**
 * The reference to the transport protocol used by the load balancing rule.
 */
export type Protocol = (typeof Protocol)[keyof typeof Protocol];
export declare const PublicIPAddressVersion: {
    /**
     * The IP configuration's public IP is IPv4.
     */
    readonly IPv4: "IPv4";
    /**
     * The IP configuration's public IP is IPv6.
     */
    readonly IPv6: "IPv6";
};
/**
 * Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
 */
export type PublicIPAddressVersion = (typeof PublicIPAddressVersion)[keyof typeof PublicIPAddressVersion];
export declare const RollingUpgradeMode: {
    /**
     * The upgrade will stop after completing each upgrade domain and automatically monitor health before proceeding. The value is 0.
     */
    readonly Monitored: "Monitored";
    /**
     * The upgrade will proceed automatically without performing any health monitoring. The value is 1.
     */
    readonly UnmonitoredAuto: "UnmonitoredAuto";
};
/**
 * The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
 */
export type RollingUpgradeMode = (typeof RollingUpgradeMode)[keyof typeof RollingUpgradeMode];
export declare const SecurityType: {
    /**
     * Trusted Launch is a security type that secures generation 2 virtual machines.
     */
    readonly TrustedLaunch: "TrustedLaunch";
    /**
     * Standard is the default security type for all machines.
     */
    readonly Standard: "Standard";
};
/**
 * Specifies the security type of the nodeType. Only Standard and TrustedLaunch are currently supported
 */
export type SecurityType = (typeof SecurityType)[keyof typeof SecurityType];
export declare const ServiceCorrelationScheme: {
    /**
     * Aligned affinity ensures that the primaries of the partitions of the affinitized services are collocated on the same nodes. This is the default and is the same as selecting the Affinity scheme. The value is 0.
     */
    readonly AlignedAffinity: "AlignedAffinity";
    /**
     * Non-Aligned affinity guarantees that all replicas of each service will be placed on the same nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will be collocated. The value is 1.
     */
    readonly NonAlignedAffinity: "NonAlignedAffinity";
};
/**
 * The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
 */
export type ServiceCorrelationScheme = (typeof ServiceCorrelationScheme)[keyof typeof ServiceCorrelationScheme];
export declare const ServiceKind: {
    /**
     * Does not use Service Fabric to make its state highly available or reliable. The value is 0.
     */
    readonly Stateless: "Stateless";
    /**
     * Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 1.
     */
    readonly Stateful: "Stateful";
};
/**
 * The kind of service (Stateless or Stateful).
 */
export type ServiceKind = (typeof ServiceKind)[keyof typeof ServiceKind];
export declare const ServiceLoadMetricWeight: {
    /**
     * Disables resource balancing for this metric. This value is zero.
     */
    readonly Zero: "Zero";
    /**
     * Specifies the metric weight of the service load as Low. The value is 1.
     */
    readonly Low: "Low";
    /**
     * Specifies the metric weight of the service load as Medium. The value is 2.
     */
    readonly Medium: "Medium";
    /**
     * Specifies the metric weight of the service load as High. The value is 3.
     */
    readonly High: "High";
};
/**
 * The service load metric relative weight, compared to other metrics configured for this service, as a number.
 */
export type ServiceLoadMetricWeight = (typeof ServiceLoadMetricWeight)[keyof typeof ServiceLoadMetricWeight];
export declare const ServicePackageActivationMode: {
    /**
     * Indicates the application package activation mode will use shared process.
     */
    readonly SharedProcess: "SharedProcess";
    /**
     * Indicates the application package activation mode will use exclusive process.
     */
    readonly ExclusiveProcess: "ExclusiveProcess";
};
/**
 * The activation Mode of the service package
 */
export type ServicePackageActivationMode = (typeof ServicePackageActivationMode)[keyof typeof ServicePackageActivationMode];
export declare const ServicePlacementPolicyType: {
    /**
     * Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or upgrade domain cannot be used for placement of this service. The value is 0.
     */
    readonly InvalidDomain: "InvalidDomain";
    /**
     * Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the service must be placed in a specific domain. The value is 1.
     */
    readonly RequiredDomain: "RequiredDomain";
    /**
     * Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the Primary replica for the partitions of the service should be located in a particular domain as an optimization. The value is 2.
     */
    readonly PreferredPrimaryDomain: "PreferredPrimaryDomain";
    /**
     * Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will disallow placement of any two replicas from the same partition in the same domain at any time. The value is 3.
     */
    readonly RequiredDomainDistribution: "RequiredDomainDistribution";
    /**
     * Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all replicas of a particular partition of the service should be placed atomically. The value is 4.
     */
    readonly NonPartiallyPlaceService: "NonPartiallyPlaceService";
};
/**
 * The type of placement policy for a service fabric service. Following are the possible values.
 */
export type ServicePlacementPolicyType = (typeof ServicePlacementPolicyType)[keyof typeof ServicePlacementPolicyType];
export declare const ServiceScalingMechanismKind: {
    /**
     * Represents a scaling mechanism for adding or removing instances of stateless service partition. The value is 0.
     */
    readonly ScalePartitionInstanceCount: "ScalePartitionInstanceCount";
    /**
     * Represents a scaling mechanism for adding or removing named partitions of a stateless service. The value is 1.
     */
    readonly AddRemoveIncrementalNamedPartition: "AddRemoveIncrementalNamedPartition";
};
/**
 * Enumerates the ways that a service can be partitioned.
 */
export type ServiceScalingMechanismKind = (typeof ServiceScalingMechanismKind)[keyof typeof ServiceScalingMechanismKind];
export declare const ServiceScalingTriggerKind: {
    /**
     * Represents a scaling trigger related to an average load of a metric/resource of a partition. The value is 0.
     */
    readonly AveragePartitionLoadTrigger: "AveragePartitionLoadTrigger";
    /**
     * Represents a scaling policy related to an average load of a metric/resource of a service. The value is 1.
     */
    readonly AverageServiceLoadTrigger: "AverageServiceLoadTrigger";
};
/**
 * Enumerates the ways that a service can be partitioned.
 */
export type ServiceScalingTriggerKind = (typeof ServiceScalingTriggerKind)[keyof typeof ServiceScalingTriggerKind];
export declare const SkuName: {
    /**
     * Basic requires a minimum of 3 nodes and allows only 1 node type.
     */
    readonly Basic: "Basic";
    /**
     * Requires a minimum of 5 nodes and allows 1 or more node type.
     */
    readonly Standard: "Standard";
};
/**
 * Sku Name.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const VmSetupAction: {
    /**
     * Enable windows containers feature.
     */
    readonly EnableContainers: "EnableContainers";
    /**
     * Enables windows HyperV feature.
     */
    readonly EnableHyperV: "EnableHyperV";
};
/**
 * action to be performed on the vms before bootstrapping the service fabric runtime.
 */
export type VmSetupAction = (typeof VmSetupAction)[keyof typeof VmSetupAction];
export declare const VmssExtensionSetupOrder: {
    /**
     * Indicates that the vm extension should run before the service fabric runtime starts.
     */
    readonly BeforeSFRuntime: "BeforeSFRuntime";
};
/**
 * Vm extension setup order.
 */
export type VmssExtensionSetupOrder = (typeof VmssExtensionSetupOrder)[keyof typeof VmssExtensionSetupOrder];
export declare const ZonalUpdateMode: {
    /**
     * The cluster will use 5 upgrade domains for Cross Az Node types.
     */
    readonly Standard: "Standard";
    /**
     * The cluster will use a maximum of 3 upgrade domains per zone instead of 5 for Cross Az Node types for faster deployments.
     */
    readonly Fast: "Fast";
};
/**
 * Indicates the update mode for Cross Az clusters.
 */
export type ZonalUpdateMode = (typeof ZonalUpdateMode)[keyof typeof ZonalUpdateMode];
