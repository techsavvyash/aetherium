import * as v20210301 from "./v20210301";
import * as v20230301preview from "./v20230301preview";
import * as v20230501 from "./v20230501";
import * as v20231101preview from "./v20231101preview";
import * as v20240301 from "./v20240301";
import * as v20240701 from "./v20240701";
export { v20210301, v20230301preview, v20230501, v20231101preview, v20240301, v20240701, };
export declare const AmlFilesystemIdentityType: {
    readonly UserAssigned: "UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource.
 */
export type AmlFilesystemIdentityType = (typeof AmlFilesystemIdentityType)[keyof typeof AmlFilesystemIdentityType];
export declare const CacheIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the cache
 */
export type CacheIdentityType = (typeof CacheIdentityType)[keyof typeof CacheIdentityType];
export declare const ConflictResolutionMode: {
    readonly Fail: "Fail";
    readonly Skip: "Skip";
    readonly OverwriteIfDirty: "OverwriteIfDirty";
    readonly OverwriteAlways: "OverwriteAlways";
};
/**
 * How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
 */
export type ConflictResolutionMode = (typeof ConflictResolutionMode)[keyof typeof ConflictResolutionMode];
export declare const MaintenanceDayOfWeekType: {
    readonly Monday: "Monday";
    readonly Tuesday: "Tuesday";
    readonly Wednesday: "Wednesday";
    readonly Thursday: "Thursday";
    readonly Friday: "Friday";
    readonly Saturday: "Saturday";
    readonly Sunday: "Sunday";
};
/**
 * Day of the week on which the maintenance window will occur.
 */
export type MaintenanceDayOfWeekType = (typeof MaintenanceDayOfWeekType)[keyof typeof MaintenanceDayOfWeekType];
export declare const NfsAccessRuleAccess: {
    readonly No: "no";
    readonly Ro: "ro";
    readonly Rw: "rw";
};
/**
 * Access allowed by this rule.
 */
export type NfsAccessRuleAccess = (typeof NfsAccessRuleAccess)[keyof typeof NfsAccessRuleAccess];
export declare const NfsAccessRuleScope: {
    readonly Default: "default";
    readonly Network: "network";
    readonly Host: "host";
};
/**
 * Scope for this rule. The scope and filter determine which clients match the rule.
 */
export type NfsAccessRuleScope = (typeof NfsAccessRuleScope)[keyof typeof NfsAccessRuleScope];
export declare const OperationalStateType: {
    readonly Ready: "Ready";
    readonly Busy: "Busy";
    readonly Suspended: "Suspended";
    readonly Flushing: "Flushing";
};
/**
 * Storage target operational state.
 */
export type OperationalStateType = (typeof OperationalStateType)[keyof typeof OperationalStateType];
export declare const StorageTargetType: {
    readonly Nfs3: "nfs3";
    readonly Clfs: "clfs";
    readonly Unknown: "unknown";
    readonly BlobNfs: "blobNfs";
};
/**
 * Type of the Storage Target.
 */
export type StorageTargetType = (typeof StorageTargetType)[keyof typeof StorageTargetType];
export declare const UsernameSource: {
    readonly AD: "AD";
    readonly LDAP: "LDAP";
    readonly File: "File";
    readonly None: "None";
};
/**
 * This setting determines how the cache gets username and group names for clients.
 */
export type UsernameSource = (typeof UsernameSource)[keyof typeof UsernameSource];
