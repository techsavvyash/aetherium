import * as v20150801preview from "./v20150801preview";
import * as v20160601 from "./v20160601";
import * as v20160801 from "./v20160801";
import * as v20160901 from "./v20160901";
import * as v20180201 from "./v20180201";
import * as v20181101 from "./v20181101";
import * as v20190801 from "./v20190801";
import * as v20200601 from "./v20200601";
import * as v20200901 from "./v20200901";
import * as v20201001 from "./v20201001";
import * as v20201201 from "./v20201201";
import * as v20210101 from "./v20210101";
import * as v20210115 from "./v20210115";
import * as v20210201 from "./v20210201";
import * as v20210301 from "./v20210301";
import * as v20220301 from "./v20220301";
import * as v20220901 from "./v20220901";
import * as v20230101 from "./v20230101";
import * as v20231201 from "./v20231201";
import * as v20240401 from "./v20240401";
export { v20150801preview, v20160601, v20160801, v20160901, v20180201, v20181101, v20190801, v20200601, v20200901, v20201001, v20201201, v20210101, v20210115, v20210201, v20210301, v20220301, v20220901, v20230101, v20231201, v20240401, };
export declare const ActiveRevisionsMode: {
    readonly Multiple: "multiple";
    readonly Single: "single";
};
/**
 * ActiveRevisionsMode controls how active revisions are handled for the Container app:
 * <list><item>Multiple: multiple revisions can be active. If no value if provided, this is the default</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode</item></list>
 */
export type ActiveRevisionsMode = (typeof ActiveRevisionsMode)[keyof typeof ActiveRevisionsMode];
export declare const ApiType: {
    readonly NotSpecified: "NotSpecified";
    readonly Rest: "Rest";
    readonly Soap: "Soap";
};
/**
 * The API type
 */
export type ApiType = (typeof ApiType)[keyof typeof ApiType];
export declare const AuthType: {
    readonly Anonymous: "Anonymous";
    readonly UserCredentials: "UserCredentials";
    readonly SystemIdentity: "SystemIdentity";
    readonly UserAssigned: "UserAssigned";
};
/**
 * Auth Type
 */
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
export declare const AutoHealActionType: {
    readonly Recycle: "Recycle";
    readonly LogEvent: "LogEvent";
    readonly CustomAction: "CustomAction";
};
/**
 * Predefined action to be taken.
 */
export type AutoHealActionType = (typeof AutoHealActionType)[keyof typeof AutoHealActionType];
export declare const AzureResourceType: {
    readonly Website: "Website";
    readonly TrafficManager: "TrafficManager";
};
/**
 * Azure resource type.
 */
export type AzureResourceType = (typeof AzureResourceType)[keyof typeof AzureResourceType];
export declare const AzureStorageType: {
    readonly AzureFiles: "AzureFiles";
    readonly AzureBlob: "AzureBlob";
};
/**
 * Type of storage.
 */
export type AzureStorageType = (typeof AzureStorageType)[keyof typeof AzureStorageType];
export declare const BuiltInAuthenticationProvider: {
    readonly AzureActiveDirectory: "AzureActiveDirectory";
    readonly Facebook: "Facebook";
    readonly Google: "Google";
    readonly MicrosoftAccount: "MicrosoftAccount";
    readonly Twitter: "Twitter";
    readonly Github: "Github";
};
/**
 * The default authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the unauthenticated client
 * action is set to "RedirectToLoginPage".
 */
export type BuiltInAuthenticationProvider = (typeof BuiltInAuthenticationProvider)[keyof typeof BuiltInAuthenticationProvider];
export declare const ClientCertMode: {
    readonly Required: "Required";
    readonly Optional: "Optional";
    readonly OptionalInteractiveUser: "OptionalInteractiveUser";
};
/**
 * This composes with ClientCertEnabled setting.
 * - ClientCertEnabled: false means ClientCert is ignored.
 * - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
 * - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
 */
export type ClientCertMode = (typeof ClientCertMode)[keyof typeof ClientCertMode];
export declare const ClientCredentialMethod: {
    readonly ClientSecretPost: "ClientSecretPost";
};
/**
 * The method that should be used to authenticate the user.
 */
export type ClientCredentialMethod = (typeof ClientCredentialMethod)[keyof typeof ClientCredentialMethod];
export declare const ConnectionParameterType: {
    readonly String: "string";
    readonly Securestring: "securestring";
    readonly Secureobject: "secureobject";
    readonly Int: "int";
    readonly Bool: "bool";
    readonly Object: "object";
    readonly Array: "array";
    readonly OauthSetting: "oauthSetting";
    readonly Connection: "connection";
};
/**
 * Type of the parameter
 */
export type ConnectionParameterType = (typeof ConnectionParameterType)[keyof typeof ConnectionParameterType];
export declare const ConnectionStringType: {
    readonly MySql: "MySql";
    readonly SQLServer: "SQLServer";
    readonly SQLAzure: "SQLAzure";
    readonly Custom: "Custom";
    readonly NotificationHub: "NotificationHub";
    readonly ServiceBus: "ServiceBus";
    readonly EventHub: "EventHub";
    readonly ApiHub: "ApiHub";
    readonly DocDb: "DocDb";
    readonly RedisCache: "RedisCache";
    readonly PostgreSQL: "PostgreSQL";
};
/**
 * Type of database.
 */
export type ConnectionStringType = (typeof ConnectionStringType)[keyof typeof ConnectionStringType];
export declare const CookieExpirationConvention: {
    readonly FixedTime: "FixedTime";
    readonly IdentityProviderDerived: "IdentityProviderDerived";
};
/**
 * The convention used when determining the session cookie's expiration.
 */
export type CookieExpirationConvention = (typeof CookieExpirationConvention)[keyof typeof CookieExpirationConvention];
export declare const CustomHostNameDnsRecordType: {
    readonly CName: "CName";
    readonly A: "A";
};
/**
 * Custom DNS record type.
 */
export type CustomHostNameDnsRecordType = (typeof CustomHostNameDnsRecordType)[keyof typeof CustomHostNameDnsRecordType];
export declare const DatabaseType: {
    readonly SqlAzure: "SqlAzure";
    readonly MySql: "MySql";
    readonly LocalMySql: "LocalMySql";
    readonly PostgreSql: "PostgreSql";
};
/**
 * Database type (e.g. SqlAzure / MySql).
 */
export type DatabaseType = (typeof DatabaseType)[keyof typeof DatabaseType];
export declare const DefaultAction: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * Default action for scm access restriction if no rules are matched.
 */
export type DefaultAction = (typeof DefaultAction)[keyof typeof DefaultAction];
export declare const EnterpriseGradeCdnStatus: {
    readonly Enabled: "Enabled";
    readonly Enabling: "Enabling";
    readonly Disabled: "Disabled";
    readonly Disabling: "Disabling";
};
/**
 * State indicating the status of the enterprise grade CDN serving traffic to the static web app.
 */
export type EnterpriseGradeCdnStatus = (typeof EnterpriseGradeCdnStatus)[keyof typeof EnterpriseGradeCdnStatus];
export declare const ForwardProxyConvention: {
    readonly NoProxy: "NoProxy";
    readonly Standard: "Standard";
    readonly Custom: "Custom";
};
/**
 * The convention used to determine the url of the request made.
 */
export type ForwardProxyConvention = (typeof ForwardProxyConvention)[keyof typeof ForwardProxyConvention];
export declare const FrequencyUnit: {
    readonly Day: "Day";
    readonly Hour: "Hour";
};
/**
 * The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
 */
export type FrequencyUnit = (typeof FrequencyUnit)[keyof typeof FrequencyUnit];
export declare const FrontEndServiceType: {
    readonly NodePort: "NodePort";
    readonly LoadBalancer: "LoadBalancer";
};
export type FrontEndServiceType = (typeof FrontEndServiceType)[keyof typeof FrontEndServiceType];
export declare const FtpsState: {
    readonly AllAllowed: "AllAllowed";
    readonly FtpsOnly: "FtpsOnly";
    readonly Disabled: "Disabled";
};
/**
 * State of FTP / FTPS service
 */
export type FtpsState = (typeof FtpsState)[keyof typeof FtpsState];
export declare const HostNameType: {
    readonly Verified: "Verified";
    readonly Managed: "Managed";
};
/**
 * Hostname type.
 */
export type HostNameType = (typeof HostNameType)[keyof typeof HostNameType];
export declare const HostType: {
    readonly Standard: "Standard";
    readonly Repository: "Repository";
};
/**
 * Indicates whether the hostname is a standard or repository hostname.
 */
export type HostType = (typeof HostType)[keyof typeof HostType];
export declare const IngressTransportMethod: {
    readonly Auto: "auto";
    readonly Http: "http";
    readonly Http2: "http2";
};
/**
 * Ingress transport protocol
 */
export type IngressTransportMethod = (typeof IngressTransportMethod)[keyof typeof IngressTransportMethod];
export declare const IpFilterTag: {
    readonly Default: "Default";
    readonly XffProxy: "XffProxy";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
 */
export type IpFilterTag = (typeof IpFilterTag)[keyof typeof IpFilterTag];
export declare const LoadBalancingMode: {
    readonly None: "None";
    readonly Web: "Web";
    readonly Publishing: "Publishing";
    readonly Web_Publishing: "Web, Publishing";
};
/**
 * Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment.
 */
export type LoadBalancingMode = (typeof LoadBalancingMode)[keyof typeof LoadBalancingMode];
export declare const LogLevel: {
    readonly Off: "Off";
    readonly Verbose: "Verbose";
    readonly Information: "Information";
    readonly Warning: "Warning";
    readonly Error: "Error";
};
/**
 * Log level.
 */
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
export declare const ManagedPipelineMode: {
    readonly Integrated: "Integrated";
    readonly Classic: "Classic";
};
/**
 * Managed pipeline mode.
 */
export type ManagedPipelineMode = (typeof ManagedPipelineMode)[keyof typeof ManagedPipelineMode];
export declare const ManagedServiceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * Type of managed service identity.
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const PublicCertificateLocation: {
    readonly CurrentUserMy: "CurrentUserMy";
    readonly LocalMachineMy: "LocalMachineMy";
    readonly Unknown: "Unknown";
};
/**
 * Public Certificate Location
 */
export type PublicCertificateLocation = (typeof PublicCertificateLocation)[keyof typeof PublicCertificateLocation];
export declare const RedundancyMode: {
    readonly None: "None";
    readonly Manual: "Manual";
    readonly Failover: "Failover";
    readonly ActiveActive: "ActiveActive";
    readonly GeoRedundant: "GeoRedundant";
};
/**
 * Site redundancy mode
 */
export type RedundancyMode = (typeof RedundancyMode)[keyof typeof RedundancyMode];
export declare const RouteType: {
    readonly DEFAULT: "DEFAULT";
    readonly INHERITED: "INHERITED";
    readonly STATIC: "STATIC";
};
/**
 * The type of route this is:
 * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
 * INHERITED - Routes inherited from the real Virtual Network routes
 * STATIC - Static route set on the app only
 *
 * These values will be used for syncing an app's routes with those from a Virtual Network.
 */
export type RouteType = (typeof RouteType)[keyof typeof RouteType];
export declare const ScmType: {
    readonly None: "None";
    readonly Dropbox: "Dropbox";
    readonly Tfs: "Tfs";
    readonly LocalGit: "LocalGit";
    readonly GitHub: "GitHub";
    readonly CodePlexGit: "CodePlexGit";
    readonly CodePlexHg: "CodePlexHg";
    readonly BitbucketGit: "BitbucketGit";
    readonly BitbucketHg: "BitbucketHg";
    readonly ExternalGit: "ExternalGit";
    readonly ExternalHg: "ExternalHg";
    readonly OneDrive: "OneDrive";
    readonly VSO: "VSO";
    readonly VSTSRM: "VSTSRM";
};
/**
 * SCM type.
 */
export type ScmType = (typeof ScmType)[keyof typeof ScmType];
export declare const SiteLoadBalancing: {
    readonly WeightedRoundRobin: "WeightedRoundRobin";
    readonly LeastRequests: "LeastRequests";
    readonly LeastResponseTime: "LeastResponseTime";
    readonly WeightedTotalTraffic: "WeightedTotalTraffic";
    readonly RequestHash: "RequestHash";
    readonly PerSiteRoundRobin: "PerSiteRoundRobin";
};
/**
 * Site load balancing.
 */
export type SiteLoadBalancing = (typeof SiteLoadBalancing)[keyof typeof SiteLoadBalancing];
export declare const SslState: {
    readonly Disabled: "Disabled";
    readonly SniEnabled: "SniEnabled";
    readonly IpBasedEnabled: "IpBasedEnabled";
};
/**
 * SSL type.
 */
export type SslState = (typeof SslState)[keyof typeof SslState];
export declare const StagingEnvironmentPolicy: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * State indicating whether staging environments are allowed or not allowed for a static web app.
 */
export type StagingEnvironmentPolicy = (typeof StagingEnvironmentPolicy)[keyof typeof StagingEnvironmentPolicy];
export declare const StorageType: {
    readonly LocalNode: "LocalNode";
    readonly NetworkFileSystem: "NetworkFileSystem";
};
export type StorageType = (typeof StorageType)[keyof typeof StorageType];
export declare const SupportedTlsVersions: {
    readonly SupportedTlsVersions_1_0: "1.0";
    readonly SupportedTlsVersions_1_1: "1.1";
    readonly SupportedTlsVersions_1_2: "1.2";
};
/**
 * ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
 */
export type SupportedTlsVersions = (typeof SupportedTlsVersions)[keyof typeof SupportedTlsVersions];
export declare const UnauthenticatedClientAction: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientAction = (typeof UnauthenticatedClientAction)[keyof typeof UnauthenticatedClientAction];
export declare const UnauthenticatedClientActionV2: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
    readonly Return401: "Return401";
    readonly Return403: "Return403";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientActionV2 = (typeof UnauthenticatedClientActionV2)[keyof typeof UnauthenticatedClientActionV2];
export declare const UpgradePreference: {
    /**
     * No preference on when this App Service Environment will be upgraded
     */
    readonly None: "None";
    /**
     * This App Service Environment will be upgraded before others in the same region that have Upgrade Preference 'Late'
     */
    readonly Early: "Early";
    /**
     * This App Service Environment will be upgraded after others in the same region that have Upgrade Preference 'Early'
     */
    readonly Late: "Late";
    /**
     * ASEv3 only. Once an upgrade is available, this App Service Environment will wait 10 days for the upgrade to be manually initiated. After 10 days the upgrade will begin automatically
     */
    readonly Manual: "Manual";
};
/**
 * Upgrade Preference
 */
export type UpgradePreference = (typeof UpgradePreference)[keyof typeof UpgradePreference];
export declare const WsdlImportMethod: {
    readonly NotSpecified: "NotSpecified";
    readonly SoapToRest: "SoapToRest";
    readonly SoapPassThrough: "SoapPassThrough";
};
/**
 * The WSDL import method
 */
export type WsdlImportMethod = (typeof WsdlImportMethod)[keyof typeof WsdlImportMethod];
