package firecracker

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"time"

	"github.com/aetherium/aetherium/pkg/types"
	"github.com/aetherium/aetherium/pkg/vmm"
)

// FirecrackerOrchestrator implements vmm.VMOrchestrator using Firecracker
type FirecrackerOrchestrator struct {
	config *Config
	vms    map[string]*vmHandle
}

// Config represents Firecracker-specific configuration
type Config struct {
	KernelPath      string
	RootFSTemplate  string
	SocketDir       string
	DefaultVCPU     int
	DefaultMemoryMB int
}

type vmHandle struct {
	vm      *types.VM
	process *exec.Cmd
	client  *FirecrackerClient
}

// NewFirecrackerOrchestrator creates a new Firecracker VMM orchestrator
func NewFirecrackerOrchestrator(configMap map[string]interface{}) (*FirecrackerOrchestrator, error) {
	config := &Config{
		KernelPath:      configMap["kernel_path"].(string),
		RootFSTemplate:  configMap["rootfs_template"].(string),
		SocketDir:       configMap["socket_dir"].(string),
		DefaultVCPU:     configMap["default_vcpu"].(int),
		DefaultMemoryMB: configMap["default_memory_mb"].(int),
	}

	return &FirecrackerOrchestrator{
		config: config,
		vms:    make(map[string]*vmHandle),
	}, nil
}

// CreateVM creates a new Firecracker VM
func (f *FirecrackerOrchestrator) CreateVM(ctx context.Context, config *types.VMConfig) (*types.VM, error) {
	// Validate that kernel and rootfs exist
	if _, err := os.Stat(config.KernelPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("kernel not found: %s", config.KernelPath)
	}
	if _, err := os.Stat(config.RootFSPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("rootfs not found: %s", config.RootFSPath)
	}

	// Create VM struct
	vm := &types.VM{
		ID:     config.ID,
		Status: types.VMStatusCreated,
		Config: *config,
	}

	// Create client for this VM
	client := NewFirecrackerClient(config.SocketPath)

	f.vms[config.ID] = &vmHandle{
		vm:     vm,
		client: client,
	}

	return vm, nil
}

// StartVM starts a Firecracker VM
func (f *FirecrackerOrchestrator) StartVM(ctx context.Context, vmID string) error {
	handle, exists := f.vms[vmID]
	if !exists {
		return fmt.Errorf("VM %s not found", vmID)
	}

	if handle.vm.Status != types.VMStatusCreated {
		return fmt.Errorf("VM %s is not in created state (current: %s)", vmID, handle.vm.Status)
	}

	// 1. Spawn Firecracker process
	if err := f.spawnFirecracker(ctx, handle); err != nil {
		return fmt.Errorf("failed to spawn firecracker: %w", err)
	}

	// 2. Wait for socket to be ready
	if err := handle.client.WaitForSocket(5 * time.Second); err != nil {
		f.killProcess(handle)
		return fmt.Errorf("socket not ready: %w", err)
	}

	// 3. Configure VM via API
	if err := f.configureVM(handle); err != nil {
		f.killProcess(handle)
		return fmt.Errorf("failed to configure VM: %w", err)
	}

	// 4. Start the instance
	if err := handle.client.StartInstance(); err != nil {
		f.killProcess(handle)
		return fmt.Errorf("failed to start instance: %w", err)
	}

	handle.vm.Status = types.VMStatusRunning
	now := time.Now()
	handle.vm.StartedAt = &now

	return nil
}

func (f *FirecrackerOrchestrator) spawnFirecracker(ctx context.Context, handle *vmHandle) error {
	// Find firecracker binary
	fcPath := f.findFirecrackerBinary()
	if fcPath == "" {
		return fmt.Errorf("firecracker binary not found in PATH or standard locations")
	}

	// Clean up any existing socket
	os.Remove(handle.vm.Config.SocketPath)

	// Spawn firecracker process
	cmd := exec.CommandContext(ctx, fcPath,
		"--api-sock", handle.vm.Config.SocketPath,
	)

	// Capture stdout/stderr for debugging
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start firecracker process: %w", err)
	}

	handle.process = cmd
	return nil
}

func (f *FirecrackerOrchestrator) findFirecrackerBinary() string {
	// Check standard locations
	locations := []string{
		"/usr/local/bin/firecracker",
		"/usr/bin/firecracker",
	}

	for _, path := range locations {
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}

	// Check PATH
	if path, err := exec.LookPath("firecracker"); err == nil {
		return path
	}

	return ""
}

func (f *FirecrackerOrchestrator) configureVM(handle *vmHandle) error {
	client := handle.client
	config := handle.vm.Config

	// Set boot source
	if err := client.PutBootSource(config.KernelPath, nil); err != nil {
		return fmt.Errorf("failed to set boot source: %w", err)
	}

	// Set machine config
	if err := client.PutMachineConfig(config.VCPUCount, config.MemoryMB); err != nil {
		return fmt.Errorf("failed to set machine config: %w", err)
	}

	// Set root drive
	if err := client.PutDrive("rootfs", config.RootFSPath, true, false); err != nil {
		return fmt.Errorf("failed to set root drive: %w", err)
	}

	return nil
}

// StopVM stops a Firecracker VM
func (f *FirecrackerOrchestrator) StopVM(ctx context.Context, vmID string, force bool) error {
	handle, exists := f.vms[vmID]
	if !exists {
		return fmt.Errorf("VM %s not found", vmID)
	}

	if handle.vm.Status != types.VMStatusRunning {
		return fmt.Errorf("VM %s is not running (status: %s)", vmID, handle.vm.Status)
	}

	handle.vm.Status = types.VMStatusStopping

	if force {
		// Force kill the process
		f.killProcess(handle)
	} else {
		// Try graceful shutdown first
		if err := handle.client.SendCtrlAltDel(); err == nil {
			// Wait for process to exit
			done := make(chan error, 1)
			go func() {
				done <- handle.process.Wait()
			}()

			select {
			case <-done:
				// Process exited gracefully
			case <-time.After(10 * time.Second):
				// Timeout, force kill
				f.killProcess(handle)
			}
		} else {
			// API call failed, force kill
			f.killProcess(handle)
		}
	}

	// Clean up socket
	os.Remove(handle.vm.Config.SocketPath)

	handle.vm.Status = types.VMStatusStopped
	now := time.Now()
	handle.vm.StoppedAt = &now

	return nil
}

func (f *FirecrackerOrchestrator) killProcess(handle *vmHandle) {
	if handle.process != nil && handle.process.Process != nil {
		handle.process.Process.Kill()
		handle.process.Wait()
	}
}

// GetVMStatus returns the current status of a VM
func (f *FirecrackerOrchestrator) GetVMStatus(ctx context.Context, vmID string) (*types.VM, error) {
	handle, exists := f.vms[vmID]
	if !exists {
		return nil, fmt.Errorf("VM %s not found", vmID)
	}

	// For running VMs, we could query Firecracker API for detailed state
	// For now, return our cached state
	return handle.vm, nil
}

// DeleteVM destroys a VM and cleans up resources
func (f *FirecrackerOrchestrator) DeleteVM(ctx context.Context, vmID string) error {
	handle, exists := f.vms[vmID]
	if !exists {
		return fmt.Errorf("VM %s not found", vmID)
	}

	// Stop if running
	if handle.vm.Status == types.VMStatusRunning {
		if err := f.StopVM(ctx, vmID, true); err != nil {
			return fmt.Errorf("failed to stop VM during delete: %w", err)
		}
	}

	// Clean up socket
	os.Remove(handle.vm.Config.SocketPath)

	// Remove from map
	delete(f.vms, vmID)

	return nil
}

// ListVMs returns all VMs
func (f *FirecrackerOrchestrator) ListVMs(ctx context.Context) ([]*types.VM, error) {
	vms := make([]*types.VM, 0, len(f.vms))
	for _, handle := range f.vms {
		vms = append(vms, handle.vm)
	}
	return vms, nil
}

// StreamLogs streams logs from a VM
func (f *FirecrackerOrchestrator) StreamLogs(ctx context.Context, vmID string) (<-chan string, error) {
	// TODO: Implement log streaming via serial console or virtio-vsock
	logChan := make(chan string)
	close(logChan)
	return logChan, nil
}

// ExecuteCommand is implemented in exec.go

// Health returns the health status of the orchestrator
func (f *FirecrackerOrchestrator) Health(ctx context.Context) error {
	// Check if firecracker binary exists
	if f.findFirecrackerBinary() == "" {
		return fmt.Errorf("firecracker binary not found")
	}

	// Check if kernel exists
	if _, err := os.Stat(f.config.KernelPath); os.IsNotExist(err) {
		return fmt.Errorf("kernel not found: %s", f.config.KernelPath)
	}

	// Check if rootfs template exists
	if _, err := os.Stat(f.config.RootFSTemplate); os.IsNotExist(err) {
		return fmt.Errorf("rootfs template not found: %s", f.config.RootFSTemplate)
	}

	// Check if /dev/kvm is accessible
	if _, err := os.Stat("/dev/kvm"); os.IsNotExist(err) {
		return fmt.Errorf("/dev/kvm not found - KVM not available")
	}

	kvm, err := os.OpenFile("/dev/kvm", os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("/dev/kvm not accessible: %w (add user to kvm group)", err)
	}
	kvm.Close()

	return nil
}

// getLastError retrieves error information (for compatibility)
func (f *FirecrackerOrchestrator) getLastError(handle *vmHandle) string {
	if handle.process != nil && handle.process.ProcessState != nil {
		return handle.process.ProcessState.String()
	}
	return ""
}

// Ensure FirecrackerOrchestrator implements vmm.VMOrchestrator
var _ vmm.VMOrchestrator = (*FirecrackerOrchestrator)(nil)
