import * as v20180501 from "./v20180501";
import * as v20190601 from "./v20190601";
import * as v20200301 from "./v20200301";
import * as v20200301preview from "./v20200301preview";
import * as v20200401preview from "./v20200401preview";
import * as v20200501 from "./v20200501";
import * as v20201001 from "./v20201001";
import * as v20201001preview from "./v20201001preview";
import * as v20210601 from "./v20210601";
import * as v20211201preview from "./v20211201preview";
import * as v20220401 from "./v20220401";
import * as v20220601 from "./v20220601";
import * as v20220701preview from "./v20220701preview";
import * as v20230401 from "./v20230401";
import * as v20240201preview from "./v20240201preview";
import * as v20240401 from "./v20240401";
import * as v20240501 from "./v20240501";
import * as v20240901preview from "./v20240901preview";
import * as v20241201preview from "./v20241201preview";
import * as v20250101 from "./v20250101";
import * as v20250301 from "./v20250301";
export { v20180501, v20190601, v20200301, v20200301preview, v20200401preview, v20200501, v20201001, v20201001preview, v20210601, v20211201preview, v20220401, v20220601, v20220701preview, v20230401, v20240201preview, v20240401, v20240501, v20240901preview, v20241201preview, v20250101, v20250301, };
export declare const AccessReviewRecurrencePatternType: {
    readonly Weekly: "weekly";
    readonly AbsoluteMonthly: "absoluteMonthly";
};
/**
 * The recurrence type : weekly, monthly, etc.
 */
export type AccessReviewRecurrencePatternType = (typeof AccessReviewRecurrencePatternType)[keyof typeof AccessReviewRecurrencePatternType];
export declare const AccessReviewRecurrenceRangeType: {
    readonly EndDate: "endDate";
    readonly NoEnd: "noEnd";
    readonly Numbered: "numbered";
};
/**
 * The recurrence range type. The possible values are: endDate, noEnd, numbered.
 */
export type AccessReviewRecurrenceRangeType = (typeof AccessReviewRecurrenceRangeType)[keyof typeof AccessReviewRecurrenceRangeType];
export declare const AccessReviewResult: {
    readonly Approve: "Approve";
    readonly Deny: "Deny";
    readonly NotReviewed: "NotReviewed";
    readonly DontKnow: "DontKnow";
    readonly NotNotified: "NotNotified";
};
/**
 * Represents a reviewer's decision for a given review
 */
export type AccessReviewResult = (typeof AccessReviewResult)[keyof typeof AccessReviewResult];
export declare const ApprovalMode: {
    readonly SingleStage: "SingleStage";
    readonly Serial: "Serial";
    readonly Parallel: "Parallel";
    readonly NoApproval: "NoApproval";
};
/**
 * The type of rule
 */
export type ApprovalMode = (typeof ApprovalMode)[keyof typeof ApprovalMode];
export declare const AssignmentScopeValidation: {
    /**
     * This option will validate the exemption is at or under the assignment scope.
     */
    readonly Default: "Default";
    /**
     * This option will bypass the validation the exemption scope is at or under the policy assignment scope.
     */
    readonly DoNotValidate: "DoNotValidate";
};
/**
 * The option whether validate the exemption is at or under the assignment scope.
 */
export type AssignmentScopeValidation = (typeof AssignmentScopeValidation)[keyof typeof AssignmentScopeValidation];
export declare const DefaultDecisionType: {
    readonly Approve: "Approve";
    readonly Deny: "Deny";
    readonly Recommendation: "Recommendation";
};
/**
 * This specifies the behavior for the autoReview feature when an access review completes.
 */
export type DefaultDecisionType = (typeof DefaultDecisionType)[keyof typeof DefaultDecisionType];
export declare const EnablementRules: {
    readonly MultiFactorAuthentication: "MultiFactorAuthentication";
    readonly Justification: "Justification";
    readonly Ticketing: "Ticketing";
};
/**
 * The type of enablement rule
 */
export type EnablementRules = (typeof EnablementRules)[keyof typeof EnablementRules];
export declare const EnforcementMode: {
    /**
     * The policy effect is enforced during resource creation or update.
     */
    readonly Default: "Default";
    /**
     * The policy effect is not enforced during resource creation or update.
     */
    readonly DoNotEnforce: "DoNotEnforce";
};
/**
 * The policy assignment enforcement mode. Possible values are Default and DoNotEnforce.
 */
export type EnforcementMode = (typeof EnforcementMode)[keyof typeof EnforcementMode];
export declare const ExcludedPrincipalTypes: {
    readonly ServicePrincipalsAsTarget: "ServicePrincipalsAsTarget";
    readonly ServicePrincipalsAsRequestor: "ServicePrincipalsAsRequestor";
};
export type ExcludedPrincipalTypes = (typeof ExcludedPrincipalTypes)[keyof typeof ExcludedPrincipalTypes];
export declare const ExemptionCategory: {
    /**
     * This category of exemptions usually means the scope is not applicable for the policy.
     */
    readonly Waiver: "Waiver";
    /**
     * This category of exemptions usually means the mitigation actions have been applied to the scope.
     */
    readonly Mitigated: "Mitigated";
};
/**
 * The policy exemption category. Possible values are Waiver and Mitigated.
 */
export type ExemptionCategory = (typeof ExemptionCategory)[keyof typeof ExemptionCategory];
export declare const LockLevel: {
    readonly NotSpecified: "NotSpecified";
    readonly CanNotDelete: "CanNotDelete";
    readonly ReadOnly: "ReadOnly";
};
/**
 * The level of the lock. Possible values are: NotSpecified, CanNotDelete, ReadOnly. CanNotDelete means authorized users are able to read and modify the resources, but not delete. ReadOnly means authorized users can only read from a resource, but they can't modify or delete it.
 */
export type LockLevel = (typeof LockLevel)[keyof typeof LockLevel];
export declare const NotificationDeliveryMechanism: {
    readonly Email: "Email";
};
/**
 * The type of notification.
 */
export type NotificationDeliveryMechanism = (typeof NotificationDeliveryMechanism)[keyof typeof NotificationDeliveryMechanism];
export declare const NotificationLevel: {
    readonly None: "None";
    readonly Critical: "Critical";
    readonly All: "All";
};
/**
 * The notification level.
 */
export type NotificationLevel = (typeof NotificationLevel)[keyof typeof NotificationLevel];
export declare const OverrideKind: {
    /**
     * It will override the policy effect type.
     */
    readonly PolicyEffect: "policyEffect";
};
/**
 * The override kind.
 */
export type OverrideKind = (typeof OverrideKind)[keyof typeof OverrideKind];
export declare const PIMOnlyMode: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
    readonly ReportOnly: "ReportOnly";
};
/**
 * Determines whether the setting is enabled, disabled or report only.
 */
export type PIMOnlyMode = (typeof PIMOnlyMode)[keyof typeof PIMOnlyMode];
export declare const ParameterType: {
    readonly String: "String";
    readonly Array: "Array";
    readonly Object: "Object";
    readonly Boolean: "Boolean";
    readonly Integer: "Integer";
    readonly Float: "Float";
    readonly DateTime: "DateTime";
};
/**
 * The data type of the parameter.
 */
export type ParameterType = (typeof ParameterType)[keyof typeof ParameterType];
export declare const PolicyType: {
    readonly NotSpecified: "NotSpecified";
    readonly BuiltIn: "BuiltIn";
    readonly Custom: "Custom";
    readonly Static: "Static";
};
/**
 * The type of policy definition. Possible values are NotSpecified, BuiltIn, Custom, and Static.
 */
export type PolicyType = (typeof PolicyType)[keyof typeof PolicyType];
export declare const PrincipalType: {
    readonly User: "User";
    readonly Group: "Group";
    readonly ServicePrincipal: "ServicePrincipal";
    readonly ForeignGroup: "ForeignGroup";
    readonly Device: "Device";
};
/**
 * The principal type of the assigned principal ID.
 */
export type PrincipalType = (typeof PrincipalType)[keyof typeof PrincipalType];
export declare const PublicNetworkAccessOptions: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
export type PublicNetworkAccessOptions = (typeof PublicNetworkAccessOptions)[keyof typeof PublicNetworkAccessOptions];
export declare const RecipientType: {
    readonly Requestor: "Requestor";
    readonly Approver: "Approver";
    readonly Admin: "Admin";
};
/**
 * The recipient type.
 */
export type RecipientType = (typeof RecipientType)[keyof typeof RecipientType];
export declare const RequestType: {
    readonly AdminAssign: "AdminAssign";
    readonly AdminRemove: "AdminRemove";
    readonly AdminUpdate: "AdminUpdate";
    readonly AdminExtend: "AdminExtend";
    readonly AdminRenew: "AdminRenew";
    readonly SelfActivate: "SelfActivate";
    readonly SelfDeactivate: "SelfDeactivate";
    readonly SelfExtend: "SelfExtend";
    readonly SelfRenew: "SelfRenew";
};
/**
 * The type of the role assignment schedule request. Eg: SelfActivate, AdminAssign etc
 */
export type RequestType = (typeof RequestType)[keyof typeof RequestType];
export declare const ResourceIdentityType: {
    /**
     * Indicates that a system assigned identity is associated with the resource.
     */
    readonly SystemAssigned: "SystemAssigned";
    /**
     * Indicates that a system assigned identity is associated with the resource.
     */
    readonly UserAssigned: "UserAssigned";
    /**
     * Indicates that no identity is associated with the resource or that the existing identity should be removed.
     */
    readonly None: "None";
};
/**
 * The identity type. This is the only required field when adding a system or user assigned identity to a resource.
 */
export type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];
export declare const RoleManagementPolicyRuleType: {
    readonly RoleManagementPolicyApprovalRule: "RoleManagementPolicyApprovalRule";
    readonly RoleManagementPolicyAuthenticationContextRule: "RoleManagementPolicyAuthenticationContextRule";
    readonly RoleManagementPolicyEnablementRule: "RoleManagementPolicyEnablementRule";
    readonly RoleManagementPolicyExpirationRule: "RoleManagementPolicyExpirationRule";
    readonly RoleManagementPolicyNotificationRule: "RoleManagementPolicyNotificationRule";
    readonly RoleManagementPolicyPimOnlyModeRule: "RoleManagementPolicyPimOnlyModeRule";
};
/**
 * The type of rule
 */
export type RoleManagementPolicyRuleType = (typeof RoleManagementPolicyRuleType)[keyof typeof RoleManagementPolicyRuleType];
export declare const SelectorKind: {
    /**
     * The selector kind to filter policies by the resource location.
     */
    readonly ResourceLocation: "resourceLocation";
    /**
     * The selector kind to filter policies by the resource type.
     */
    readonly ResourceType: "resourceType";
    /**
     * The selector kind to filter policies by the resource without location.
     */
    readonly ResourceWithoutLocation: "resourceWithoutLocation";
    /**
     * The selector kind to filter policies by the policy definition reference ID.
     */
    readonly PolicyDefinitionReferenceId: "policyDefinitionReferenceId";
};
/**
 * The selector kind.
 */
export type SelectorKind = (typeof SelectorKind)[keyof typeof SelectorKind];
export declare const Type: {
    readonly AfterDuration: "AfterDuration";
    readonly AfterDateTime: "AfterDateTime";
    readonly NoExpiration: "NoExpiration";
};
/**
 * Type of the role eligibility schedule expiration
 */
export type Type = (typeof Type)[keyof typeof Type];
export declare const UserType: {
    readonly User: "User";
    readonly Group: "Group";
    readonly ServicePrincipal: "ServicePrincipal";
};
/**
 * The type of user.
 */
export type UserType = (typeof UserType)[keyof typeof UserType];
