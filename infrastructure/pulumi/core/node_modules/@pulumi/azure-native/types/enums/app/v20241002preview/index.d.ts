export declare const AccessMode: {
    readonly ReadOnly: "ReadOnly";
    readonly ReadWrite: "ReadWrite";
};
/**
 * Access mode for storage
 */
export type AccessMode = (typeof AccessMode)[keyof typeof AccessMode];
export declare const Action: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
 */
export type Action = (typeof Action)[keyof typeof Action];
export declare const ActiveRevisionsMode: {
    readonly Multiple: "Multiple";
    readonly Single: "Single";
    readonly Labels: "Labels";
};
/**
 * ActiveRevisionsMode controls how active revisions are handled for the Container app:
 * <list><item>Single: Only one revision can be active at a time. Traffic weights cannot be used. This is the default.</item><item>Multiple: Multiple revisions can be active, including optional traffic weights and labels.</item><item>Labels: Only revisions with labels are active. Traffic weights can be applied to labels.</item></list>
 */
export type ActiveRevisionsMode = (typeof ActiveRevisionsMode)[keyof typeof ActiveRevisionsMode];
export declare const Affinity: {
    readonly Sticky: "sticky";
    readonly None: "none";
};
/**
 * Sticky Session Affinity
 */
export type Affinity = (typeof Affinity)[keyof typeof Affinity];
export declare const AppProtocol: {
    readonly Http: "http";
    readonly Grpc: "grpc";
};
/**
 * Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
 */
export type AppProtocol = (typeof AppProtocol)[keyof typeof AppProtocol];
export declare const BindingType: {
    readonly Disabled: "Disabled";
    readonly SniEnabled: "SniEnabled";
    readonly Auto: "Auto";
};
/**
 * Custom Domain binding type.
 */
export type BindingType = (typeof BindingType)[keyof typeof BindingType];
export declare const CertificateType: {
    readonly ServerSSLCertificate: "ServerSSLCertificate";
    readonly ImagePullTrustedCA: "ImagePullTrustedCA";
};
/**
 * The type of the certificate. Allowed values are `ServerSSLCertificate` and `ImagePullTrustedCA`
 */
export type CertificateType = (typeof CertificateType)[keyof typeof CertificateType];
export declare const ClientCredentialMethod: {
    readonly ClientSecretPost: "ClientSecretPost";
};
/**
 * The method that should be used to authenticate the user.
 */
export type ClientCredentialMethod = (typeof ClientCredentialMethod)[keyof typeof ClientCredentialMethod];
export declare const ContainerType: {
    readonly CustomContainer: "CustomContainer";
    readonly PythonLTS: "PythonLTS";
};
/**
 * The container type of the sessions.
 */
export type ContainerType = (typeof ContainerType)[keyof typeof ContainerType];
export declare const CookieExpirationConvention: {
    readonly FixedTime: "FixedTime";
    readonly IdentityProviderDerived: "IdentityProviderDerived";
};
/**
 * The convention used when determining the session cookie's expiration.
 */
export type CookieExpirationConvention = (typeof CookieExpirationConvention)[keyof typeof CookieExpirationConvention];
export declare const DotNetComponentType: {
    readonly AspireDashboard: "AspireDashboard";
};
/**
 * Type of the .NET Component.
 */
export type DotNetComponentType = (typeof DotNetComponentType)[keyof typeof DotNetComponentType];
export declare const ExecutionType: {
    readonly Timed: "Timed";
};
/**
 * The execution type of the session pool.
 */
export type ExecutionType = (typeof ExecutionType)[keyof typeof ExecutionType];
export declare const ExtendedLocationTypes: {
    readonly CustomLocation: "CustomLocation";
};
/**
 * The type of the extended location.
 */
export type ExtendedLocationTypes = (typeof ExtendedLocationTypes)[keyof typeof ExtendedLocationTypes];
export declare const ForwardProxyConvention: {
    readonly NoProxy: "NoProxy";
    readonly Standard: "Standard";
    readonly Custom: "Custom";
};
/**
 * The convention used to determine the url of the request made.
 */
export type ForwardProxyConvention = (typeof ForwardProxyConvention)[keyof typeof ForwardProxyConvention];
export declare const IdentitySettingsLifeCycle: {
    readonly Init: "Init";
    readonly Main: "Main";
    readonly None: "None";
    readonly All: "All";
};
/**
 * Use to select the lifecycle stages of a Container App during which the Managed Identity should be available.
 */
export type IdentitySettingsLifeCycle = (typeof IdentitySettingsLifeCycle)[keyof typeof IdentitySettingsLifeCycle];
export declare const ImageType: {
    readonly CloudBuild: "CloudBuild";
    readonly ContainerImage: "ContainerImage";
};
/**
 * The type of the image. Set to CloudBuild to let the system manages the image, where user will not be able to update image through image field. Set to ContainerImage for user provided image.
 */
export type ImageType = (typeof ImageType)[keyof typeof ImageType];
export declare const IngressClientCertificateMode: {
    readonly Ignore: "ignore";
    readonly Accept: "accept";
    readonly Require: "require";
};
/**
 * Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
 */
export type IngressClientCertificateMode = (typeof IngressClientCertificateMode)[keyof typeof IngressClientCertificateMode];
export declare const IngressTargetPortHttpScheme: {
    readonly Http: "http";
    readonly Https: "https";
};
/**
 * Whether an http app listens on http or https
 */
export type IngressTargetPortHttpScheme = (typeof IngressTargetPortHttpScheme)[keyof typeof IngressTargetPortHttpScheme];
export declare const IngressTransportMethod: {
    readonly Auto: "auto";
    readonly Http: "http";
    readonly Http2: "http2";
    readonly Tcp: "tcp";
};
/**
 * Ingress transport protocol
 */
export type IngressTransportMethod = (typeof IngressTransportMethod)[keyof typeof IngressTransportMethod];
export declare const JavaComponentType: {
    readonly SpringBootAdmin: "SpringBootAdmin";
    readonly SpringCloudEureka: "SpringCloudEureka";
    readonly SpringCloudConfig: "SpringCloudConfig";
    readonly SpringCloudGateway: "SpringCloudGateway";
    readonly Nacos: "Nacos";
};
/**
 * Type of the Java Component.
 */
export type JavaComponentType = (typeof JavaComponentType)[keyof typeof JavaComponentType];
export declare const Kind: {
    readonly Workflowapp: "workflowapp";
};
/**
 * Metadata used to render different experiences for resources of the same type; e.g. WorkflowApp is a kind of Microsoft.App/ContainerApps type. If supported, the resource provider must validate and persist this value.
 */
export type Kind = (typeof Kind)[keyof typeof Kind];
export declare const Level: {
    readonly Off: "off";
    readonly Error: "error";
    readonly Info: "info";
    readonly Debug: "debug";
    readonly Trace: "trace";
    readonly Warn: "warn";
};
/**
 * The specified logger's log level.
 */
export type Level = (typeof Level)[keyof typeof Level];
export declare const LogLevel: {
    readonly Info: "info";
    readonly Debug: "debug";
    readonly Warn: "warn";
    readonly Error: "error";
};
/**
 * Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
 */
export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
export declare const ManagedCertificateDomainControlValidation: {
    readonly CNAME: "CNAME";
    readonly HTTP: "HTTP";
    readonly TXT: "TXT";
};
/**
 * Selected type of domain control validation for managed certificates.
 */
export type ManagedCertificateDomainControlValidation = (typeof ManagedCertificateDomainControlValidation)[keyof typeof ManagedCertificateDomainControlValidation];
export declare const ManagedServiceIdentityType: {
    readonly None: "None";
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned,UserAssigned";
};
/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];
export declare const PatchingMode: {
    readonly Automatic: "Automatic";
    readonly Manual: "Manual";
    readonly Disabled: "Disabled";
};
/**
 * Patching mode for the container app. Null or default in this field will be interpreted as Automatic by RP. Automatic mode will automatically apply available patches. Manual mode will require the user to manually apply patches. Disabled mode will stop patch detection and auto patching.
 */
export type PatchingMode = (typeof PatchingMode)[keyof typeof PatchingMode];
export declare const PoolManagementType: {
    readonly Manual: "Manual";
    readonly Dynamic: "Dynamic";
};
/**
 * The pool management type of the session pool.
 */
export type PoolManagementType = (typeof PoolManagementType)[keyof typeof PoolManagementType];
export declare const PrivateEndpointServiceConnectionStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
};
/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];
export declare const PublicNetworkAccess: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled'.
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];
export declare const Scheme: {
    readonly HTTP: "HTTP";
    readonly HTTPS: "HTTPS";
};
/**
 * Scheme to use for connecting to the host. Defaults to HTTP.
 */
export type Scheme = (typeof Scheme)[keyof typeof Scheme];
export declare const SessionNetworkStatus: {
    readonly EgressEnabled: "EgressEnabled";
    readonly EgressDisabled: "EgressDisabled";
};
/**
 * Network status for the sessions.
 */
export type SessionNetworkStatus = (typeof SessionNetworkStatus)[keyof typeof SessionNetworkStatus];
export declare const StorageType: {
    readonly AzureFile: "AzureFile";
    readonly EmptyDir: "EmptyDir";
    readonly Secret: "Secret";
    readonly NfsAzureFile: "NfsAzureFile";
    readonly Smb: "Smb";
};
/**
 * Storage type for the volume. If not provided, use EmptyDir.
 */
export type StorageType = (typeof StorageType)[keyof typeof StorageType];
export declare const TriggerType: {
    readonly Schedule: "Schedule";
    readonly Event: "Event";
    readonly Manual: "Manual";
};
/**
 * Trigger type of the job
 */
export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType];
export declare const Type: {
    readonly Liveness: "Liveness";
    readonly Readiness: "Readiness";
    readonly Startup: "Startup";
};
/**
 * The type of probe.
 */
export type Type = (typeof Type)[keyof typeof Type];
export declare const UnauthenticatedClientActionV2: {
    readonly RedirectToLoginPage: "RedirectToLoginPage";
    readonly AllowAnonymous: "AllowAnonymous";
    readonly Return401: "Return401";
    readonly Return403: "Return403";
};
/**
 * The action to take when an unauthenticated client attempts to access the app.
 */
export type UnauthenticatedClientActionV2 = (typeof UnauthenticatedClientActionV2)[keyof typeof UnauthenticatedClientActionV2];
export declare const WeekDay: {
    readonly Monday: "Monday";
    readonly Tuesday: "Tuesday";
    readonly Wednesday: "Wednesday";
    readonly Thursday: "Thursday";
    readonly Friday: "Friday";
    readonly Saturday: "Saturday";
    readonly Sunday: "Sunday";
};
/**
 * Day of the week when a managed environment can be patched.
 */
export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay];
