export declare const Access: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The access type of the rule.
 */
export type Access = (typeof Access)[keyof typeof Access];
export declare const ActionType: {
    readonly AnomalyScoring: "AnomalyScoring";
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly JSChallenge: "JSChallenge";
};
/**
 * Describes the override action to be applied when rule matches.
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const AddressPrefixType: {
    readonly IPPrefix: "IPPrefix";
    readonly ServiceTag: "ServiceTag";
};
/**
 * Address prefix type.
 */
export type AddressPrefixType = (typeof AddressPrefixType)[keyof typeof AddressPrefixType];
export declare const AdminRuleKind: {
    readonly Custom: "Custom";
    readonly Default: "Default";
};
/**
 * Whether the rule is custom or default.
 */
export type AdminRuleKind = (typeof AdminRuleKind)[keyof typeof AdminRuleKind];
export declare const AdminState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Property to indicate if the Express Route Gateway serves traffic when there are multiple Express Route Gateways in the vnet
 */
export type AdminState = (typeof AdminState)[keyof typeof AdminState];
export declare const ApplicationGatewayClientRevocationOptions: {
    readonly None: "None";
    readonly OCSP: "OCSP";
};
/**
 * Verify client certificate revocation status.
 */
export type ApplicationGatewayClientRevocationOptions = (typeof ApplicationGatewayClientRevocationOptions)[keyof typeof ApplicationGatewayClientRevocationOptions];
export declare const ApplicationGatewayCookieBasedAffinity: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Cookie based affinity.
 */
export type ApplicationGatewayCookieBasedAffinity = (typeof ApplicationGatewayCookieBasedAffinity)[keyof typeof ApplicationGatewayCookieBasedAffinity];
export declare const ApplicationGatewayCustomErrorStatusCode: {
    readonly HttpStatus400: "HttpStatus400";
    readonly HttpStatus403: "HttpStatus403";
    readonly HttpStatus404: "HttpStatus404";
    readonly HttpStatus405: "HttpStatus405";
    readonly HttpStatus408: "HttpStatus408";
    readonly HttpStatus500: "HttpStatus500";
    readonly HttpStatus502: "HttpStatus502";
    readonly HttpStatus503: "HttpStatus503";
    readonly HttpStatus504: "HttpStatus504";
};
/**
 * Status code of the application gateway custom error.
 */
export type ApplicationGatewayCustomErrorStatusCode = (typeof ApplicationGatewayCustomErrorStatusCode)[keyof typeof ApplicationGatewayCustomErrorStatusCode];
export declare const ApplicationGatewayFirewallMode: {
    readonly Detection: "Detection";
    readonly Prevention: "Prevention";
};
/**
 * Web application firewall mode.
 */
export type ApplicationGatewayFirewallMode = (typeof ApplicationGatewayFirewallMode)[keyof typeof ApplicationGatewayFirewallMode];
export declare const ApplicationGatewayFirewallRateLimitDuration: {
    readonly OneMin: "OneMin";
    readonly FiveMins: "FiveMins";
};
/**
 * Duration over which Rate Limit policy will be applied. Applies only when ruleType is RateLimitRule.
 */
export type ApplicationGatewayFirewallRateLimitDuration = (typeof ApplicationGatewayFirewallRateLimitDuration)[keyof typeof ApplicationGatewayFirewallRateLimitDuration];
export declare const ApplicationGatewayFirewallUserSessionVariable: {
    readonly ClientAddr: "ClientAddr";
    readonly GeoLocation: "GeoLocation";
    readonly None: "None";
};
/**
 * User Session clause variable.
 */
export type ApplicationGatewayFirewallUserSessionVariable = (typeof ApplicationGatewayFirewallUserSessionVariable)[keyof typeof ApplicationGatewayFirewallUserSessionVariable];
export declare const ApplicationGatewayLoadDistributionAlgorithm: {
    readonly RoundRobin: "RoundRobin";
    readonly LeastConnections: "LeastConnections";
    readonly IpHash: "IpHash";
};
/**
 * Load Distribution Targets resource of an application gateway.
 */
export type ApplicationGatewayLoadDistributionAlgorithm = (typeof ApplicationGatewayLoadDistributionAlgorithm)[keyof typeof ApplicationGatewayLoadDistributionAlgorithm];
export declare const ApplicationGatewayProtocol: {
    /**
     * Supported for httpListeners and  backendHttpSettingsCollection properties.
     */
    readonly Http: "Http";
    /**
     * Supported for httpListeners and  backendHttpSettingsCollection properties.
     */
    readonly Https: "Https";
    /**
     * Supported for listeners and backendSettingsCollection properties.
     */
    readonly Tcp: "Tcp";
    /**
     * Supported for listeners and backendSettingsCollection properties.
     */
    readonly Tls: "Tls";
};
/**
 * The protocol used for the probe.
 */
export type ApplicationGatewayProtocol = (typeof ApplicationGatewayProtocol)[keyof typeof ApplicationGatewayProtocol];
export declare const ApplicationGatewayRedirectType: {
    readonly Permanent: "Permanent";
    readonly Found: "Found";
    readonly SeeOther: "SeeOther";
    readonly Temporary: "Temporary";
};
/**
 * HTTP redirection type.
 */
export type ApplicationGatewayRedirectType = (typeof ApplicationGatewayRedirectType)[keyof typeof ApplicationGatewayRedirectType];
export declare const ApplicationGatewayRequestRoutingRuleType: {
    readonly Basic: "Basic";
    readonly PathBasedRouting: "PathBasedRouting";
};
/**
 * Rule type.
 */
export type ApplicationGatewayRequestRoutingRuleType = (typeof ApplicationGatewayRequestRoutingRuleType)[keyof typeof ApplicationGatewayRequestRoutingRuleType];
export declare const ApplicationGatewaySkuFamily: {
    readonly Generation_1: "Generation_1";
    readonly Generation_2: "Generation_2";
};
/**
 * Family of an application gateway SKU.
 */
export type ApplicationGatewaySkuFamily = (typeof ApplicationGatewaySkuFamily)[keyof typeof ApplicationGatewaySkuFamily];
export declare const ApplicationGatewaySkuName: {
    readonly Standard_Small: "Standard_Small";
    readonly Standard_Medium: "Standard_Medium";
    readonly Standard_Large: "Standard_Large";
    readonly WAF_Medium: "WAF_Medium";
    readonly WAF_Large: "WAF_Large";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
    readonly Basic: "Basic";
};
/**
 * Name of an application gateway SKU.
 */
export type ApplicationGatewaySkuName = (typeof ApplicationGatewaySkuName)[keyof typeof ApplicationGatewaySkuName];
export declare const ApplicationGatewaySslCipherSuite: {
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_DHE_RSA_WITH_AES_256_CBC_SHA: "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_128_CBC_SHA: "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_AES_256_GCM_SHA384: "TLS_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_RSA_WITH_AES_128_GCM_SHA256: "TLS_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA256: "TLS_RSA_WITH_AES_256_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA256: "TLS_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA: "TLS_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA: "TLS_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_3DES_EDE_CBC_SHA: "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
};
/**
 * Ssl cipher suites enums.
 */
export type ApplicationGatewaySslCipherSuite = (typeof ApplicationGatewaySslCipherSuite)[keyof typeof ApplicationGatewaySslCipherSuite];
export declare const ApplicationGatewaySslPolicyName: {
    readonly AppGwSslPolicy20150501: "AppGwSslPolicy20150501";
    readonly AppGwSslPolicy20170401: "AppGwSslPolicy20170401";
    readonly AppGwSslPolicy20170401S: "AppGwSslPolicy20170401S";
    readonly AppGwSslPolicy20220101: "AppGwSslPolicy20220101";
    readonly AppGwSslPolicy20220101S: "AppGwSslPolicy20220101S";
};
/**
 * Name of Ssl predefined policy.
 */
export type ApplicationGatewaySslPolicyName = (typeof ApplicationGatewaySslPolicyName)[keyof typeof ApplicationGatewaySslPolicyName];
export declare const ApplicationGatewaySslPolicyType: {
    readonly Predefined: "Predefined";
    readonly Custom: "Custom";
    readonly CustomV2: "CustomV2";
};
/**
 * Type of Ssl Policy.
 */
export type ApplicationGatewaySslPolicyType = (typeof ApplicationGatewaySslPolicyType)[keyof typeof ApplicationGatewaySslPolicyType];
export declare const ApplicationGatewaySslProtocol: {
    readonly TLSv1_0: "TLSv1_0";
    readonly TLSv1_1: "TLSv1_1";
    readonly TLSv1_2: "TLSv1_2";
    readonly TLSv1_3: "TLSv1_3";
};
/**
 * Minimum version of Ssl protocol to be supported on application gateway.
 */
export type ApplicationGatewaySslProtocol = (typeof ApplicationGatewaySslProtocol)[keyof typeof ApplicationGatewaySslProtocol];
export declare const ApplicationGatewayTier: {
    readonly Standard: "Standard";
    readonly WAF: "WAF";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
    readonly Basic: "Basic";
};
/**
 * Tier of an application gateway.
 */
export type ApplicationGatewayTier = (typeof ApplicationGatewayTier)[keyof typeof ApplicationGatewayTier];
export declare const AuthorizationUseStatus: {
    readonly Available: "Available";
    readonly InUse: "InUse";
};
/**
 * The authorization use status.
 */
export type AuthorizationUseStatus = (typeof AuthorizationUseStatus)[keyof typeof AuthorizationUseStatus];
export declare const AutoLearnPrivateRangesMode: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * The operation mode for automatically learning private ranges to not be SNAT
 */
export type AutoLearnPrivateRangesMode = (typeof AutoLearnPrivateRangesMode)[keyof typeof AutoLearnPrivateRangesMode];
export declare const AzureFirewallApplicationRuleProtocolType: {
    readonly Http: "Http";
    readonly Https: "Https";
    readonly Mssql: "Mssql";
};
/**
 * Protocol type.
 */
export type AzureFirewallApplicationRuleProtocolType = (typeof AzureFirewallApplicationRuleProtocolType)[keyof typeof AzureFirewallApplicationRuleProtocolType];
export declare const AzureFirewallNatRCActionType: {
    readonly Snat: "Snat";
    readonly Dnat: "Dnat";
};
/**
 * The type of action.
 */
export type AzureFirewallNatRCActionType = (typeof AzureFirewallNatRCActionType)[keyof typeof AzureFirewallNatRCActionType];
export declare const AzureFirewallNetworkRuleProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
    readonly ICMP: "ICMP";
};
/**
 * The protocol of a Network Rule resource.
 */
export type AzureFirewallNetworkRuleProtocol = (typeof AzureFirewallNetworkRuleProtocol)[keyof typeof AzureFirewallNetworkRuleProtocol];
export declare const AzureFirewallRCActionType: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The type of action.
 */
export type AzureFirewallRCActionType = (typeof AzureFirewallRCActionType)[keyof typeof AzureFirewallRCActionType];
export declare const AzureFirewallSkuName: {
    readonly AZFW_VNet: "AZFW_VNet";
    readonly AZFW_Hub: "AZFW_Hub";
};
/**
 * Name of an Azure Firewall SKU.
 */
export type AzureFirewallSkuName = (typeof AzureFirewallSkuName)[keyof typeof AzureFirewallSkuName];
export declare const AzureFirewallSkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
};
/**
 * Tier of an Azure Firewall.
 */
export type AzureFirewallSkuTier = (typeof AzureFirewallSkuTier)[keyof typeof AzureFirewallSkuTier];
export declare const AzureFirewallThreatIntelMode: {
    readonly Alert: "Alert";
    readonly Deny: "Deny";
    readonly Off: "Off";
};
/**
 * The operation mode for Threat Intelligence.
 */
export type AzureFirewallThreatIntelMode = (typeof AzureFirewallThreatIntelMode)[keyof typeof AzureFirewallThreatIntelMode];
export declare const BastionHostSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Developer: "Developer";
    readonly Premium: "Premium";
};
/**
 * The name of the sku of this Bastion Host.
 */
export type BastionHostSkuName = (typeof BastionHostSkuName)[keyof typeof BastionHostSkuName];
export declare const CommissionedState: {
    readonly Provisioning: "Provisioning";
    readonly Provisioned: "Provisioned";
    readonly Commissioning: "Commissioning";
    readonly CommissionedNoInternetAdvertise: "CommissionedNoInternetAdvertise";
    readonly Commissioned: "Commissioned";
    readonly Decommissioning: "Decommissioning";
    readonly Deprovisioning: "Deprovisioning";
    readonly Deprovisioned: "Deprovisioned";
};
/**
 * The commissioned state of the Custom IP Prefix.
 */
export type CommissionedState = (typeof CommissionedState)[keyof typeof CommissionedState];
export declare const ConfigurationType: {
    readonly SecurityAdmin: "SecurityAdmin";
    readonly Connectivity: "Connectivity";
};
/**
 * Configuration Deployment Type.
 */
export type ConfigurationType = (typeof ConfigurationType)[keyof typeof ConfigurationType];
export declare const ConnectionMonitorEndpointFilterItemType: {
    readonly AgentAddress: "AgentAddress";
};
/**
 * The type of item included in the filter. Currently only 'AgentAddress' is supported.
 */
export type ConnectionMonitorEndpointFilterItemType = (typeof ConnectionMonitorEndpointFilterItemType)[keyof typeof ConnectionMonitorEndpointFilterItemType];
export declare const ConnectionMonitorEndpointFilterType: {
    readonly Include: "Include";
};
/**
 * The behavior of the endpoint filter. Currently only 'Include' is supported.
 */
export type ConnectionMonitorEndpointFilterType = (typeof ConnectionMonitorEndpointFilterType)[keyof typeof ConnectionMonitorEndpointFilterType];
export declare const ConnectionMonitorTestConfigurationProtocol: {
    readonly Tcp: "Tcp";
    readonly Http: "Http";
    readonly Icmp: "Icmp";
};
/**
 * The protocol to use in test evaluation.
 */
export type ConnectionMonitorTestConfigurationProtocol = (typeof ConnectionMonitorTestConfigurationProtocol)[keyof typeof ConnectionMonitorTestConfigurationProtocol];
export declare const ConnectivityTopology: {
    readonly HubAndSpoke: "HubAndSpoke";
    readonly Mesh: "Mesh";
};
/**
 * Connectivity topology type.
 */
export type ConnectivityTopology = (typeof ConnectivityTopology)[keyof typeof ConnectivityTopology];
export declare const CoverageLevel: {
    readonly Default: "Default";
    readonly Low: "Low";
    readonly BelowAverage: "BelowAverage";
    readonly Average: "Average";
    readonly AboveAverage: "AboveAverage";
    readonly Full: "Full";
};
/**
 * Test coverage for the endpoint.
 */
export type CoverageLevel = (typeof CoverageLevel)[keyof typeof CoverageLevel];
export declare const CustomIpPrefixType: {
    readonly Singular: "Singular";
    readonly Parent: "Parent";
    readonly Child: "Child";
};
/**
 * Type of custom IP prefix. Should be Singular, Parent, or Child.
 */
export type CustomIpPrefixType = (typeof CustomIpPrefixType)[keyof typeof CustomIpPrefixType];
export declare const DdosSettingsProtectionMode: {
    readonly VirtualNetworkInherited: "VirtualNetworkInherited";
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * The DDoS protection mode of the public IP
 */
export type DdosSettingsProtectionMode = (typeof DdosSettingsProtectionMode)[keyof typeof DdosSettingsProtectionMode];
export declare const DeleteExistingPeering: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to remove current existing peerings.
 */
export type DeleteExistingPeering = (typeof DeleteExistingPeering)[keyof typeof DeleteExistingPeering];
export declare const DeleteOptions: {
    readonly Delete: "Delete";
    readonly Detach: "Detach";
};
/**
 * Specify what happens to the public IP address when the VM using it is deleted
 */
export type DeleteOptions = (typeof DeleteOptions)[keyof typeof DeleteOptions];
export declare const DestinationPortBehavior: {
    readonly None: "None";
    readonly ListenIfAvailable: "ListenIfAvailable";
};
/**
 * Destination port behavior.
 */
export type DestinationPortBehavior = (typeof DestinationPortBehavior)[keyof typeof DestinationPortBehavior];
export declare const DhGroup: {
    readonly None: "None";
    readonly DHGroup1: "DHGroup1";
    readonly DHGroup2: "DHGroup2";
    readonly DHGroup14: "DHGroup14";
    readonly DHGroup2048: "DHGroup2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly DHGroup24: "DHGroup24";
};
/**
 * The DH Group used in IKE Phase 1 for initial SA.
 */
export type DhGroup = (typeof DhGroup)[keyof typeof DhGroup];
export declare const EndpointType: {
    readonly AzureVM: "AzureVM";
    readonly AzureVNet: "AzureVNet";
    readonly AzureSubnet: "AzureSubnet";
    readonly ExternalAddress: "ExternalAddress";
    readonly MMAWorkspaceMachine: "MMAWorkspaceMachine";
    readonly MMAWorkspaceNetwork: "MMAWorkspaceNetwork";
    readonly AzureArcVM: "AzureArcVM";
    readonly AzureVMSS: "AzureVMSS";
    readonly AzureArcNetwork: "AzureArcNetwork";
};
/**
 * The endpoint type.
 */
export type EndpointType = (typeof EndpointType)[keyof typeof EndpointType];
export declare const ExpressRouteCircuitPeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of peering.
 */
export type ExpressRouteCircuitPeeringState = (typeof ExpressRouteCircuitPeeringState)[keyof typeof ExpressRouteCircuitPeeringState];
export declare const ExpressRouteCircuitSkuFamily: {
    readonly UnlimitedData: "UnlimitedData";
    readonly MeteredData: "MeteredData";
};
/**
 * The family of the SKU.
 */
export type ExpressRouteCircuitSkuFamily = (typeof ExpressRouteCircuitSkuFamily)[keyof typeof ExpressRouteCircuitSkuFamily];
export declare const ExpressRouteCircuitSkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
    readonly Local: "Local";
};
/**
 * The tier of the SKU.
 */
export type ExpressRouteCircuitSkuTier = (typeof ExpressRouteCircuitSkuTier)[keyof typeof ExpressRouteCircuitSkuTier];
export declare const ExpressRouteLinkAdminState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Administrative state of the physical port.
 */
export type ExpressRouteLinkAdminState = (typeof ExpressRouteLinkAdminState)[keyof typeof ExpressRouteLinkAdminState];
export declare const ExpressRouteLinkMacSecCipher: {
    readonly GcmAes256: "GcmAes256";
    readonly GcmAes128: "GcmAes128";
    readonly GcmAesXpn128: "GcmAesXpn128";
    readonly GcmAesXpn256: "GcmAesXpn256";
};
/**
 * Mac security cipher.
 */
export type ExpressRouteLinkMacSecCipher = (typeof ExpressRouteLinkMacSecCipher)[keyof typeof ExpressRouteLinkMacSecCipher];
export declare const ExpressRouteLinkMacSecSciState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Sci mode enabled/disabled.
 */
export type ExpressRouteLinkMacSecSciState = (typeof ExpressRouteLinkMacSecSciState)[keyof typeof ExpressRouteLinkMacSecSciState];
export declare const ExpressRoutePeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The peering state.
 */
export type ExpressRoutePeeringState = (typeof ExpressRoutePeeringState)[keyof typeof ExpressRoutePeeringState];
export declare const ExpressRoutePeeringType: {
    readonly AzurePublicPeering: "AzurePublicPeering";
    readonly AzurePrivatePeering: "AzurePrivatePeering";
    readonly MicrosoftPeering: "MicrosoftPeering";
};
/**
 * The peering type.
 */
export type ExpressRoutePeeringType = (typeof ExpressRoutePeeringType)[keyof typeof ExpressRoutePeeringType];
export declare const ExpressRoutePortsBillingType: {
    readonly MeteredData: "MeteredData";
    readonly UnlimitedData: "UnlimitedData";
};
/**
 * The billing type of the ExpressRoutePort resource.
 */
export type ExpressRoutePortsBillingType = (typeof ExpressRoutePortsBillingType)[keyof typeof ExpressRoutePortsBillingType];
export declare const ExpressRoutePortsEncapsulation: {
    readonly Dot1Q: "Dot1Q";
    readonly QinQ: "QinQ";
};
/**
 * Encapsulation method on physical ports.
 */
export type ExpressRoutePortsEncapsulation = (typeof ExpressRoutePortsEncapsulation)[keyof typeof ExpressRoutePortsEncapsulation];
export declare const ExtendedLocationTypes: {
    readonly EdgeZone: "EdgeZone";
};
/**
 * The type of the extended location.
 */
export type ExtendedLocationTypes = (typeof ExtendedLocationTypes)[keyof typeof ExtendedLocationTypes];
export declare const FirewallPolicyFilterRuleCollectionActionType: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The type of action.
 */
export type FirewallPolicyFilterRuleCollectionActionType = (typeof FirewallPolicyFilterRuleCollectionActionType)[keyof typeof FirewallPolicyFilterRuleCollectionActionType];
export declare const FirewallPolicyIDPSQuerySortOrder: {
    readonly Ascending: "Ascending";
    readonly Descending: "Descending";
};
/**
 * Describes if results should be in ascending/descending order
 */
export type FirewallPolicyIDPSQuerySortOrder = (typeof FirewallPolicyIDPSQuerySortOrder)[keyof typeof FirewallPolicyIDPSQuerySortOrder];
export declare const FirewallPolicyIntrusionDetectionProfileType: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Advanced: "Advanced";
    readonly Extended: "Extended";
};
/**
 * IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
 */
export type FirewallPolicyIntrusionDetectionProfileType = (typeof FirewallPolicyIntrusionDetectionProfileType)[keyof typeof FirewallPolicyIntrusionDetectionProfileType];
export declare const FirewallPolicyIntrusionDetectionProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly ICMP: "ICMP";
    readonly ANY: "ANY";
};
/**
 * The rule bypass protocol.
 */
export type FirewallPolicyIntrusionDetectionProtocol = (typeof FirewallPolicyIntrusionDetectionProtocol)[keyof typeof FirewallPolicyIntrusionDetectionProtocol];
export declare const FirewallPolicyIntrusionDetectionStateType: {
    readonly Off: "Off";
    readonly Alert: "Alert";
    readonly Deny: "Deny";
};
/**
 * Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
 */
export type FirewallPolicyIntrusionDetectionStateType = (typeof FirewallPolicyIntrusionDetectionStateType)[keyof typeof FirewallPolicyIntrusionDetectionStateType];
export declare const FirewallPolicyNatRuleCollectionActionType: {
    readonly DNAT: "DNAT";
};
/**
 * The type of action.
 */
export type FirewallPolicyNatRuleCollectionActionType = (typeof FirewallPolicyNatRuleCollectionActionType)[keyof typeof FirewallPolicyNatRuleCollectionActionType];
export declare const FirewallPolicyRuleApplicationProtocolType: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol type.
 */
export type FirewallPolicyRuleApplicationProtocolType = (typeof FirewallPolicyRuleApplicationProtocolType)[keyof typeof FirewallPolicyRuleApplicationProtocolType];
export declare const FirewallPolicyRuleCollectionType: {
    readonly FirewallPolicyNatRuleCollection: "FirewallPolicyNatRuleCollection";
    readonly FirewallPolicyFilterRuleCollection: "FirewallPolicyFilterRuleCollection";
};
/**
 * The type of the rule collection.
 */
export type FirewallPolicyRuleCollectionType = (typeof FirewallPolicyRuleCollectionType)[keyof typeof FirewallPolicyRuleCollectionType];
export declare const FirewallPolicyRuleNetworkProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
    readonly ICMP: "ICMP";
};
/**
 * The Network protocol of a Rule.
 */
export type FirewallPolicyRuleNetworkProtocol = (typeof FirewallPolicyRuleNetworkProtocol)[keyof typeof FirewallPolicyRuleNetworkProtocol];
export declare const FirewallPolicyRuleType: {
    readonly ApplicationRule: "ApplicationRule";
    readonly NetworkRule: "NetworkRule";
    readonly NatRule: "NatRule";
};
/**
 * Rule Type.
 */
export type FirewallPolicyRuleType = (typeof FirewallPolicyRuleType)[keyof typeof FirewallPolicyRuleType];
export declare const FirewallPolicySkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
};
/**
 * Tier of Firewall Policy.
 */
export type FirewallPolicySkuTier = (typeof FirewallPolicySkuTier)[keyof typeof FirewallPolicySkuTier];
export declare const FlowLogFormatType: {
    readonly JSON: "JSON";
};
/**
 * The file type of flow log.
 */
export type FlowLogFormatType = (typeof FlowLogFormatType)[keyof typeof FlowLogFormatType];
export declare const GatewayLoadBalancerTunnelInterfaceType: {
    readonly None: "None";
    readonly Internal: "Internal";
    readonly External: "External";
};
/**
 * Traffic type of gateway load balancer tunnel interface.
 */
export type GatewayLoadBalancerTunnelInterfaceType = (typeof GatewayLoadBalancerTunnelInterfaceType)[keyof typeof GatewayLoadBalancerTunnelInterfaceType];
export declare const GatewayLoadBalancerTunnelProtocol: {
    readonly None: "None";
    readonly Native: "Native";
    readonly VXLAN: "VXLAN";
};
/**
 * Protocol of gateway load balancer tunnel interface.
 */
export type GatewayLoadBalancerTunnelProtocol = (typeof GatewayLoadBalancerTunnelProtocol)[keyof typeof GatewayLoadBalancerTunnelProtocol];
export declare const Geo: {
    readonly GLOBAL: "GLOBAL";
    readonly AFRI: "AFRI";
    readonly APAC: "APAC";
    readonly EURO: "EURO";
    readonly LATAM: "LATAM";
    readonly NAM: "NAM";
    readonly ME: "ME";
    readonly OCEANIA: "OCEANIA";
    readonly AQ: "AQ";
};
/**
 * The Geo for CIDR advertising. Should be an Geo code.
 */
export type Geo = (typeof Geo)[keyof typeof Geo];
export declare const GroupConnectivity: {
    readonly None: "None";
    readonly DirectlyConnected: "DirectlyConnected";
};
/**
 * Group connectivity type.
 */
export type GroupConnectivity = (typeof GroupConnectivity)[keyof typeof GroupConnectivity];
export declare const HTTPConfigurationMethod: {
    readonly Get: "Get";
    readonly Post: "Post";
};
/**
 * The HTTP method to use.
 */
export type HTTPConfigurationMethod = (typeof HTTPConfigurationMethod)[keyof typeof HTTPConfigurationMethod];
export declare const HubRoutingPreference: {
    readonly ExpressRoute: "ExpressRoute";
    readonly VpnGateway: "VpnGateway";
    readonly ASPath: "ASPath";
};
/**
 * The hubRoutingPreference of this VirtualHub.
 */
export type HubRoutingPreference = (typeof HubRoutingPreference)[keyof typeof HubRoutingPreference];
export declare const IPAllocationMethod: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The private IP address allocation method.
 */
export type IPAllocationMethod = (typeof IPAllocationMethod)[keyof typeof IPAllocationMethod];
export declare const IPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
 */
export type IPVersion = (typeof IPVersion)[keyof typeof IPVersion];
export declare const IkeEncryption: {
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE encryption algorithm (IKE phase 2).
 */
export type IkeEncryption = (typeof IkeEncryption)[keyof typeof IkeEncryption];
export declare const IkeIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly SHA384: "SHA384";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE integrity algorithm (IKE phase 2).
 */
export type IkeIntegrity = (typeof IkeIntegrity)[keyof typeof IkeIntegrity];
export declare const IpAllocationType: {
    readonly Undefined: "Undefined";
    readonly Hypernet: "Hypernet";
};
/**
 * The type for the IpAllocation.
 */
export type IpAllocationType = (typeof IpAllocationType)[keyof typeof IpAllocationType];
export declare const IpsecEncryption: {
    readonly None: "None";
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec encryption algorithm (IKE phase 1).
 */
export type IpsecEncryption = (typeof IpsecEncryption)[keyof typeof IpsecEncryption];
export declare const IpsecIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec integrity algorithm (IKE phase 1).
 */
export type IpsecIntegrity = (typeof IpsecIntegrity)[keyof typeof IpsecIntegrity];
export declare const IsGlobal: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if global mesh is supported.
 */
export type IsGlobal = (typeof IsGlobal)[keyof typeof IsGlobal];
export declare const LoadBalancerBackendAddressAdminState: {
    readonly None: "None";
    readonly Up: "Up";
    readonly Down: "Down";
};
/**
 * A list of administrative states which once set can override health probe so that Load Balancer will always forward new connections to backend, or deny new connections and reset existing connections.
 */
export type LoadBalancerBackendAddressAdminState = (typeof LoadBalancerBackendAddressAdminState)[keyof typeof LoadBalancerBackendAddressAdminState];
export declare const LoadBalancerOutboundRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly All: "All";
};
/**
 * The protocol for the outbound rule in load balancer.
 */
export type LoadBalancerOutboundRuleProtocol = (typeof LoadBalancerOutboundRuleProtocol)[keyof typeof LoadBalancerOutboundRuleProtocol];
export declare const LoadBalancerSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
    readonly Gateway: "Gateway";
};
/**
 * Name of a load balancer SKU.
 */
export type LoadBalancerSkuName = (typeof LoadBalancerSkuName)[keyof typeof LoadBalancerSkuName];
export declare const LoadBalancerSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a load balancer SKU.
 */
export type LoadBalancerSkuTier = (typeof LoadBalancerSkuTier)[keyof typeof LoadBalancerSkuTier];
export declare const LoadDistribution: {
    readonly Default: "Default";
    readonly SourceIP: "SourceIP";
    readonly SourceIPProtocol: "SourceIPProtocol";
};
/**
 * The load distribution policy for this rule.
 */
export type LoadDistribution = (typeof LoadDistribution)[keyof typeof LoadDistribution];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of the managed rule. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const NatGatewaySkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of Nat Gateway SKU.
 */
export type NatGatewaySkuName = (typeof NatGatewaySkuName)[keyof typeof NatGatewaySkuName];
export declare const NetworkIntentPolicyBasedService: {
    readonly None: "None";
    readonly All: "All";
    readonly AllowRulesOnly: "AllowRulesOnly";
};
/**
 * Network intent policy based services.
 */
export type NetworkIntentPolicyBasedService = (typeof NetworkIntentPolicyBasedService)[keyof typeof NetworkIntentPolicyBasedService];
export declare const NetworkInterfaceAuxiliaryMode: {
    readonly None: "None";
    readonly MaxConnections: "MaxConnections";
    readonly Floating: "Floating";
    readonly AcceleratedConnections: "AcceleratedConnections";
};
/**
 * Auxiliary mode of Network Interface resource.
 */
export type NetworkInterfaceAuxiliaryMode = (typeof NetworkInterfaceAuxiliaryMode)[keyof typeof NetworkInterfaceAuxiliaryMode];
export declare const NetworkInterfaceAuxiliarySku: {
    readonly None: "None";
    readonly A1: "A1";
    readonly A2: "A2";
    readonly A4: "A4";
    readonly A8: "A8";
};
/**
 * Auxiliary sku of Network Interface resource.
 */
export type NetworkInterfaceAuxiliarySku = (typeof NetworkInterfaceAuxiliarySku)[keyof typeof NetworkInterfaceAuxiliarySku];
export declare const NetworkInterfaceMigrationPhase: {
    readonly None: "None";
    readonly Prepare: "Prepare";
    readonly Commit: "Commit";
    readonly Abort: "Abort";
    readonly Committed: "Committed";
};
/**
 * Migration phase of Network Interface resource.
 */
export type NetworkInterfaceMigrationPhase = (typeof NetworkInterfaceMigrationPhase)[keyof typeof NetworkInterfaceMigrationPhase];
export declare const NetworkInterfaceNicType: {
    readonly Standard: "Standard";
    readonly Elastic: "Elastic";
};
/**
 * Type of Network Interface resource.
 */
export type NetworkInterfaceNicType = (typeof NetworkInterfaceNicType)[keyof typeof NetworkInterfaceNicType];
export declare const NextStep: {
    readonly Unknown: "Unknown";
    readonly Continue: "Continue";
    readonly Terminate: "Terminate";
};
/**
 * Next step after rule is evaluated. Current supported behaviors are 'Continue'(to next rule) and 'Terminate'.
 */
export type NextStep = (typeof NextStep)[keyof typeof NextStep];
export declare const NicTypeInRequest: {
    readonly PublicNic: "PublicNic";
    readonly PrivateNic: "PrivateNic";
};
/**
 * NIC type. This should be either PublicNic or PrivateNic.
 */
export type NicTypeInRequest = (typeof NicTypeInRequest)[keyof typeof NicTypeInRequest];
export declare const OutputType: {
    readonly Workspace: "Workspace";
};
/**
 * Connection monitor output destination type. Currently, only "Workspace" is supported.
 */
export type OutputType = (typeof OutputType)[keyof typeof OutputType];
export declare const OwaspCrsExclusionEntryMatchVariable: {
    readonly RequestHeaderNames: "RequestHeaderNames";
    readonly RequestCookieNames: "RequestCookieNames";
    readonly RequestArgNames: "RequestArgNames";
    readonly RequestHeaderKeys: "RequestHeaderKeys";
    readonly RequestHeaderValues: "RequestHeaderValues";
    readonly RequestCookieKeys: "RequestCookieKeys";
    readonly RequestCookieValues: "RequestCookieValues";
    readonly RequestArgKeys: "RequestArgKeys";
    readonly RequestArgValues: "RequestArgValues";
};
/**
 * The variable to be excluded.
 */
export type OwaspCrsExclusionEntryMatchVariable = (typeof OwaspCrsExclusionEntryMatchVariable)[keyof typeof OwaspCrsExclusionEntryMatchVariable];
export declare const OwaspCrsExclusionEntrySelectorMatchOperator: {
    readonly Equals: "Equals";
    readonly Contains: "Contains";
    readonly StartsWith: "StartsWith";
    readonly EndsWith: "EndsWith";
    readonly EqualsAny: "EqualsAny";
};
/**
 * When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to.
 */
export type OwaspCrsExclusionEntrySelectorMatchOperator = (typeof OwaspCrsExclusionEntrySelectorMatchOperator)[keyof typeof OwaspCrsExclusionEntrySelectorMatchOperator];
export declare const PacketCaptureTargetType: {
    readonly AzureVM: "AzureVM";
    readonly AzureVMSS: "AzureVMSS";
};
/**
 * Target type of the resource provided.
 */
export type PacketCaptureTargetType = (typeof PacketCaptureTargetType)[keyof typeof PacketCaptureTargetType];
export declare const PcProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
};
/**
 * Protocol to be filtered on.
 */
export type PcProtocol = (typeof PcProtocol)[keyof typeof PcProtocol];
export declare const PfsGroup: {
    readonly None: "None";
    readonly PFS1: "PFS1";
    readonly PFS2: "PFS2";
    readonly PFS2048: "PFS2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly PFS24: "PFS24";
    readonly PFS14: "PFS14";
};
/**
 * The Pfs Group used in IKE Phase 2 for new child SA.
 */
export type PfsGroup = (typeof PfsGroup)[keyof typeof PfsGroup];
export declare const PreferredIPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters.
 */
export type PreferredIPVersion = (typeof PreferredIPVersion)[keyof typeof PreferredIPVersion];
export declare const PreferredRoutingGateway: {
    readonly ExpressRoute: "ExpressRoute";
    readonly VpnGateway: "VpnGateway";
    readonly None: "None";
};
/**
 * The preferred gateway to route on-prem traffic
 */
export type PreferredRoutingGateway = (typeof PreferredRoutingGateway)[keyof typeof PreferredRoutingGateway];
export declare const ProbeNoHealthyBackendsBehavior: {
    /**
     * No new flows will be sent to the backend pool.
     */
    readonly AllProbedDown: "AllProbedDown";
    /**
     * When all backend instances are probed down, incoming packets will be sent to all instances.
     */
    readonly AllProbedUp: "AllProbedUp";
};
/**
 * Determines how new connections are handled by the load balancer when all backend instances are probed down.
 */
export type ProbeNoHealthyBackendsBehavior = (typeof ProbeNoHealthyBackendsBehavior)[keyof typeof ProbeNoHealthyBackendsBehavior];
export declare const ProbeProtocol: {
    readonly Http: "Http";
    readonly Tcp: "Tcp";
    readonly Https: "Https";
};
/**
 * The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const ProtocolType: {
    readonly DoNotUse: "DoNotUse";
    readonly Icmp: "Icmp";
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Gre: "Gre";
    readonly Esp: "Esp";
    readonly Ah: "Ah";
    readonly Vxlan: "Vxlan";
    readonly All: "All";
};
/**
 * RNM supported protocol types.
 */
export type ProtocolType = (typeof ProtocolType)[keyof typeof ProtocolType];
export declare const PublicIPAddressMigrationPhase: {
    readonly None: "None";
    readonly Prepare: "Prepare";
    readonly Commit: "Commit";
    readonly Abort: "Abort";
    readonly Committed: "Committed";
};
/**
 * Migration phase of Public IP Address.
 */
export type PublicIPAddressMigrationPhase = (typeof PublicIPAddressMigrationPhase)[keyof typeof PublicIPAddressMigrationPhase];
export declare const PublicIPAddressSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * Name of a public IP address SKU.
 */
export type PublicIPAddressSkuName = (typeof PublicIPAddressSkuName)[keyof typeof PublicIPAddressSkuName];
export declare const PublicIPAddressSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a public IP address SKU.
 */
export type PublicIPAddressSkuTier = (typeof PublicIPAddressSkuTier)[keyof typeof PublicIPAddressSkuTier];
export declare const PublicIPPrefixSkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of a public IP prefix SKU.
 */
export type PublicIPPrefixSkuName = (typeof PublicIPPrefixSkuName)[keyof typeof PublicIPPrefixSkuName];
export declare const PublicIPPrefixSkuTier: {
    readonly Regional: "Regional";
    readonly Global: "Global";
};
/**
 * Tier of a public IP prefix SKU.
 */
export type PublicIPPrefixSkuTier = (typeof PublicIPPrefixSkuTier)[keyof typeof PublicIPPrefixSkuTier];
export declare const PublicIpAddressDnsSettingsDomainNameLabelScope: {
    readonly TenantReuse: "TenantReuse";
    readonly SubscriptionReuse: "SubscriptionReuse";
    readonly ResourceGroupReuse: "ResourceGroupReuse";
    readonly NoReuse: "NoReuse";
};
/**
 * The domain name label scope. If a domain name label and a domain name label scope are specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system with a hashed value includes in FQDN.
 */
export type PublicIpAddressDnsSettingsDomainNameLabelScope = (typeof PublicIpAddressDnsSettingsDomainNameLabelScope)[keyof typeof PublicIpAddressDnsSettingsDomainNameLabelScope];
export declare const ResourceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
 */
export type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];
export declare const RouteFilterRuleType: {
    readonly Community: "Community";
};
/**
 * The rule type of the rule.
 */
export type RouteFilterRuleType = (typeof RouteFilterRuleType)[keyof typeof RouteFilterRuleType];
export declare const RouteMapActionType: {
    readonly Unknown: "Unknown";
    readonly Remove: "Remove";
    readonly Add: "Add";
    readonly Replace: "Replace";
    readonly Drop: "Drop";
};
/**
 * Type of action to be taken. Supported types are 'Remove', 'Add', 'Replace', and 'Drop.'
 */
export type RouteMapActionType = (typeof RouteMapActionType)[keyof typeof RouteMapActionType];
export declare const RouteMapMatchCondition: {
    readonly Unknown: "Unknown";
    readonly Contains: "Contains";
    readonly Equals: "Equals";
    readonly NotContains: "NotContains";
    readonly NotEquals: "NotEquals";
};
/**
 * Match condition to apply RouteMap rules.
 */
export type RouteMapMatchCondition = (typeof RouteMapMatchCondition)[keyof typeof RouteMapMatchCondition];
export declare const RouteNextHopType: {
    readonly VirtualNetworkGateway: "VirtualNetworkGateway";
    readonly VnetLocal: "VnetLocal";
    readonly Internet: "Internet";
    readonly VirtualAppliance: "VirtualAppliance";
    readonly None: "None";
};
/**
 * The type of Azure hop the packet should be sent to.
 */
export type RouteNextHopType = (typeof RouteNextHopType)[keyof typeof RouteNextHopType];
export declare const ScrubbingRuleEntryMatchOperator: {
    readonly Equals: "Equals";
    readonly EqualsAny: "EqualsAny";
};
/**
 * When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
 */
export type ScrubbingRuleEntryMatchOperator = (typeof ScrubbingRuleEntryMatchOperator)[keyof typeof ScrubbingRuleEntryMatchOperator];
export declare const ScrubbingRuleEntryMatchVariable: {
    readonly RequestHeaderNames: "RequestHeaderNames";
    readonly RequestCookieNames: "RequestCookieNames";
    readonly RequestArgNames: "RequestArgNames";
    readonly RequestPostArgNames: "RequestPostArgNames";
    readonly RequestJSONArgNames: "RequestJSONArgNames";
    readonly RequestIPAddress: "RequestIPAddress";
};
/**
 * The variable to be scrubbed from the logs.
 */
export type ScrubbingRuleEntryMatchVariable = (typeof ScrubbingRuleEntryMatchVariable)[keyof typeof ScrubbingRuleEntryMatchVariable];
export declare const ScrubbingRuleEntryState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Defines the state of log scrubbing rule. Default value is Enabled.
 */
export type ScrubbingRuleEntryState = (typeof ScrubbingRuleEntryState)[keyof typeof ScrubbingRuleEntryState];
export declare const SecurityConfigurationRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
    readonly AlwaysAllow: "AlwaysAllow";
};
/**
 * Indicates the access allowed for this particular rule
 */
export type SecurityConfigurationRuleAccess = (typeof SecurityConfigurationRuleAccess)[keyof typeof SecurityConfigurationRuleAccess];
export declare const SecurityConfigurationRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * Indicates if the traffic matched against the rule in inbound or outbound.
 */
export type SecurityConfigurationRuleDirection = (typeof SecurityConfigurationRuleDirection)[keyof typeof SecurityConfigurationRuleDirection];
export declare const SecurityConfigurationRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Any: "Any";
    readonly Ah: "Ah";
};
/**
 * Network protocol this rule applies to.
 */
export type SecurityConfigurationRuleProtocol = (typeof SecurityConfigurationRuleProtocol)[keyof typeof SecurityConfigurationRuleProtocol];
export declare const SecurityProviderName: {
    readonly ZScaler: "ZScaler";
    readonly IBoss: "IBoss";
    readonly Checkpoint: "Checkpoint";
};
/**
 * The security provider name.
 */
export type SecurityProviderName = (typeof SecurityProviderName)[keyof typeof SecurityProviderName];
export declare const SecurityRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The network traffic is allowed or denied.
 */
export type SecurityRuleAccess = (typeof SecurityRuleAccess)[keyof typeof SecurityRuleAccess];
export declare const SecurityRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
 */
export type SecurityRuleDirection = (typeof SecurityRuleDirection)[keyof typeof SecurityRuleDirection];
export declare const SecurityRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Asterisk: "*";
    readonly Ah: "Ah";
};
/**
 * Network protocol this rule applies to.
 */
export type SecurityRuleProtocol = (typeof SecurityRuleProtocol)[keyof typeof SecurityRuleProtocol];
export declare const ServiceProviderProvisioningState: {
    readonly NotProvisioned: "NotProvisioned";
    readonly Provisioning: "Provisioning";
    readonly Provisioned: "Provisioned";
    readonly Deprovisioning: "Deprovisioning";
};
/**
 * The ServiceProviderProvisioningState state of the resource.
 */
export type ServiceProviderProvisioningState = (typeof ServiceProviderProvisioningState)[keyof typeof ServiceProviderProvisioningState];
export declare const SharingScope: {
    readonly Tenant: "Tenant";
    readonly DelegatedServices: "DelegatedServices";
};
/**
 * Set this property to Tenant to allow sharing subnet with other subscriptions in your AAD tenant. This property can only be set if defaultOutboundAccess is set to false, both properties can only be set if subnet is empty.
 */
export type SharingScope = (typeof SharingScope)[keyof typeof SharingScope];
export declare const SyncMode: {
    readonly Automatic: "Automatic";
    readonly Manual: "Manual";
};
/**
 * Backend address synchronous mode for the backend pool
 */
export type SyncMode = (typeof SyncMode)[keyof typeof SyncMode];
export declare const TransportProtocol: {
    readonly Udp: "Udp";
    readonly Tcp: "Tcp";
    readonly All: "All";
};
/**
 * The reference to the transport protocol used by the load balancing rule.
 */
export type TransportProtocol = (typeof TransportProtocol)[keyof typeof TransportProtocol];
export declare const UseHubGateway: {
    readonly False: "False";
    readonly True: "True";
};
/**
 * Flag if need to use hub gateway.
 */
export type UseHubGateway = (typeof UseHubGateway)[keyof typeof UseHubGateway];
export declare const VirtualNetworkEncryptionEnforcement: {
    readonly DropUnencrypted: "DropUnencrypted";
    readonly AllowUnencrypted: "AllowUnencrypted";
};
/**
 * If the encrypted VNet allows VM that does not support encryption
 */
export type VirtualNetworkEncryptionEnforcement = (typeof VirtualNetworkEncryptionEnforcement)[keyof typeof VirtualNetworkEncryptionEnforcement];
export declare const VirtualNetworkGatewayConnectionMode: {
    readonly Default: "Default";
    readonly ResponderOnly: "ResponderOnly";
    readonly InitiatorOnly: "InitiatorOnly";
};
/**
 * The connection mode for this connection.
 */
export type VirtualNetworkGatewayConnectionMode = (typeof VirtualNetworkGatewayConnectionMode)[keyof typeof VirtualNetworkGatewayConnectionMode];
export declare const VirtualNetworkGatewayConnectionProtocol: {
    readonly IKEv2: "IKEv2";
    readonly IKEv1: "IKEv1";
};
/**
 * Connection protocol used for this connection.
 */
export type VirtualNetworkGatewayConnectionProtocol = (typeof VirtualNetworkGatewayConnectionProtocol)[keyof typeof VirtualNetworkGatewayConnectionProtocol];
export declare const VirtualNetworkGatewayConnectionType: {
    readonly IPsec: "IPsec";
    readonly Vnet2Vnet: "Vnet2Vnet";
    readonly ExpressRoute: "ExpressRoute";
    readonly VPNClient: "VPNClient";
};
/**
 * Gateway connection type.
 */
export type VirtualNetworkGatewayConnectionType = (typeof VirtualNetworkGatewayConnectionType)[keyof typeof VirtualNetworkGatewayConnectionType];
export declare const VirtualNetworkGatewaySkuName: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw4: "VpnGw4";
    readonly VpnGw5: "VpnGw5";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly VpnGw4AZ: "VpnGw4AZ";
    readonly VpnGw5AZ: "VpnGw5AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
    readonly ErGwScale: "ErGwScale";
};
/**
 * Gateway SKU name.
 */
export type VirtualNetworkGatewaySkuName = (typeof VirtualNetworkGatewaySkuName)[keyof typeof VirtualNetworkGatewaySkuName];
export declare const VirtualNetworkGatewaySkuTier: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw4: "VpnGw4";
    readonly VpnGw5: "VpnGw5";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly VpnGw4AZ: "VpnGw4AZ";
    readonly VpnGw5AZ: "VpnGw5AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
    readonly ErGwScale: "ErGwScale";
};
/**
 * Gateway SKU tier.
 */
export type VirtualNetworkGatewaySkuTier = (typeof VirtualNetworkGatewaySkuTier)[keyof typeof VirtualNetworkGatewaySkuTier];
export declare const VirtualNetworkGatewayType: {
    readonly Vpn: "Vpn";
    readonly ExpressRoute: "ExpressRoute";
    readonly LocalGateway: "LocalGateway";
};
/**
 * The type of this virtual network gateway.
 */
export type VirtualNetworkGatewayType = (typeof VirtualNetworkGatewayType)[keyof typeof VirtualNetworkGatewayType];
export declare const VirtualNetworkPeeringLevel: {
    readonly FullyInSync: "FullyInSync";
    readonly RemoteNotInSync: "RemoteNotInSync";
    readonly LocalNotInSync: "LocalNotInSync";
    readonly LocalAndRemoteNotInSync: "LocalAndRemoteNotInSync";
};
/**
 * The peering sync status of the virtual network peering.
 */
export type VirtualNetworkPeeringLevel = (typeof VirtualNetworkPeeringLevel)[keyof typeof VirtualNetworkPeeringLevel];
export declare const VirtualNetworkPeeringState: {
    readonly Initiated: "Initiated";
    readonly Connected: "Connected";
    readonly Disconnected: "Disconnected";
};
/**
 * The status of the virtual network peering.
 */
export type VirtualNetworkPeeringState = (typeof VirtualNetworkPeeringState)[keyof typeof VirtualNetworkPeeringState];
export declare const VirtualNetworkPrivateEndpointNetworkPolicies: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
    readonly NetworkSecurityGroupEnabled: "NetworkSecurityGroupEnabled";
    readonly RouteTableEnabled: "RouteTableEnabled";
};
/**
 * Enable or Disable apply network policies on private end point in the subnet.
 */
export type VirtualNetworkPrivateEndpointNetworkPolicies = (typeof VirtualNetworkPrivateEndpointNetworkPolicies)[keyof typeof VirtualNetworkPrivateEndpointNetworkPolicies];
export declare const VirtualNetworkPrivateLinkServiceNetworkPolicies: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Enable or Disable apply network policies on private link service in the subnet.
 */
export type VirtualNetworkPrivateLinkServiceNetworkPolicies = (typeof VirtualNetworkPrivateLinkServiceNetworkPolicies)[keyof typeof VirtualNetworkPrivateLinkServiceNetworkPolicies];
export declare const VnetLocalRouteOverrideCriteria: {
    readonly Contains: "Contains";
    readonly Equal: "Equal";
};
/**
 * Parameter determining whether NVA in spoke vnet is bypassed for traffic with destination in spoke.
 */
export type VnetLocalRouteOverrideCriteria = (typeof VnetLocalRouteOverrideCriteria)[keyof typeof VnetLocalRouteOverrideCriteria];
export declare const VpnAuthenticationType: {
    readonly Certificate: "Certificate";
    readonly Radius: "Radius";
    readonly AAD: "AAD";
};
/**
 * VPN authentication types enabled for the VpnServerConfiguration.
 */
export type VpnAuthenticationType = (typeof VpnAuthenticationType)[keyof typeof VpnAuthenticationType];
export declare const VpnClientProtocol: {
    readonly IkeV2: "IkeV2";
    readonly SSTP: "SSTP";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN client protocol enabled for the virtual network gateway.
 */
export type VpnClientProtocol = (typeof VpnClientProtocol)[keyof typeof VpnClientProtocol];
export declare const VpnGatewayGeneration: {
    readonly None: "None";
    readonly Generation1: "Generation1";
    readonly Generation2: "Generation2";
};
/**
 * The generation for this VirtualNetworkGateway. Must be None if gatewayType is not VPN.
 */
export type VpnGatewayGeneration = (typeof VpnGatewayGeneration)[keyof typeof VpnGatewayGeneration];
export declare const VpnGatewayTunnelingProtocol: {
    readonly IkeV2: "IkeV2";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN protocol enabled for the VpnServerConfiguration.
 */
export type VpnGatewayTunnelingProtocol = (typeof VpnGatewayTunnelingProtocol)[keyof typeof VpnGatewayTunnelingProtocol];
export declare const VpnLinkConnectionMode: {
    readonly Default: "Default";
    readonly ResponderOnly: "ResponderOnly";
    readonly InitiatorOnly: "InitiatorOnly";
};
/**
 * Vpn link connection mode.
 */
export type VpnLinkConnectionMode = (typeof VpnLinkConnectionMode)[keyof typeof VpnLinkConnectionMode];
export declare const VpnNatRuleMode: {
    readonly EgressSnat: "EgressSnat";
    readonly IngressSnat: "IngressSnat";
};
/**
 * The Source NAT direction of a VPN NAT.
 */
export type VpnNatRuleMode = (typeof VpnNatRuleMode)[keyof typeof VpnNatRuleMode];
export declare const VpnNatRuleType: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The type of NAT rule for VPN NAT.
 */
export type VpnNatRuleType = (typeof VpnNatRuleType)[keyof typeof VpnNatRuleType];
export declare const VpnPolicyMemberAttributeType: {
    readonly CertificateGroupId: "CertificateGroupId";
    readonly AADGroupId: "AADGroupId";
    readonly RadiusAzureGroupId: "RadiusAzureGroupId";
};
/**
 * The Vpn Policy member attribute type.
 */
export type VpnPolicyMemberAttributeType = (typeof VpnPolicyMemberAttributeType)[keyof typeof VpnPolicyMemberAttributeType];
export declare const VpnType: {
    readonly PolicyBased: "PolicyBased";
    readonly RouteBased: "RouteBased";
};
/**
 * The type of this virtual network gateway.
 */
export type VpnType = (typeof VpnType)[keyof typeof VpnType];
export declare const WebApplicationFirewallAction: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly JSChallenge: "JSChallenge";
};
/**
 * Type of Actions.
 */
export type WebApplicationFirewallAction = (typeof WebApplicationFirewallAction)[keyof typeof WebApplicationFirewallAction];
export declare const WebApplicationFirewallEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of the policy.
 */
export type WebApplicationFirewallEnabledState = (typeof WebApplicationFirewallEnabledState)[keyof typeof WebApplicationFirewallEnabledState];
export declare const WebApplicationFirewallMatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeaders: "RequestHeaders";
    readonly RequestBody: "RequestBody";
    readonly RequestCookies: "RequestCookies";
};
/**
 * Match Variable.
 */
export type WebApplicationFirewallMatchVariable = (typeof WebApplicationFirewallMatchVariable)[keyof typeof WebApplicationFirewallMatchVariable];
export declare const WebApplicationFirewallMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * The mode of the policy.
 */
export type WebApplicationFirewallMode = (typeof WebApplicationFirewallMode)[keyof typeof WebApplicationFirewallMode];
export declare const WebApplicationFirewallOperator: {
    readonly IPMatch: "IPMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly Regex: "Regex";
    readonly GeoMatch: "GeoMatch";
    readonly Any: "Any";
};
/**
 * The operator to be matched.
 */
export type WebApplicationFirewallOperator = (typeof WebApplicationFirewallOperator)[keyof typeof WebApplicationFirewallOperator];
export declare const WebApplicationFirewallRuleType: {
    readonly MatchRule: "MatchRule";
    readonly RateLimitRule: "RateLimitRule";
    readonly Invalid: "Invalid";
};
/**
 * The rule type.
 */
export type WebApplicationFirewallRuleType = (typeof WebApplicationFirewallRuleType)[keyof typeof WebApplicationFirewallRuleType];
export declare const WebApplicationFirewallScrubbingState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * State of the log scrubbing config. Default value is Enabled.
 */
export type WebApplicationFirewallScrubbingState = (typeof WebApplicationFirewallScrubbingState)[keyof typeof WebApplicationFirewallScrubbingState];
export declare const WebApplicationFirewallState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type WebApplicationFirewallState = (typeof WebApplicationFirewallState)[keyof typeof WebApplicationFirewallState];
export declare const WebApplicationFirewallTransform: {
    readonly Uppercase: "Uppercase";
    readonly Lowercase: "Lowercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
    readonly HtmlEntityDecode: "HtmlEntityDecode";
};
/**
 * Transforms applied before matching.
 */
export type WebApplicationFirewallTransform = (typeof WebApplicationFirewallTransform)[keyof typeof WebApplicationFirewallTransform];
